--- spal60sr\src\base\ProcessCtrl.original.cpp	Tue Apr 29 12:10:00 2003
+++ spal60sr\src\base\ProcessCtrl.cpp	Tue Apr 29 12:10:00 2003
@@ -5,6 +5,23 @@
 #include <algorithm>	//sort関数
 #include <process>	//マルチスレッド用
 
+#define ADD_ENTRY_MODULE         1
+#define FIX_GET_MODULE_FROM_NAME 1
+#define SHOW_ERROR_MESSAGE       1
+#define OPTIMIZE_LOADHEAPLIST    1
+
+#if defined(PROCESS_MONITOR) && PROCESS_MONITOR
+#include "ProcessMonitor.h"
+#endif
+
+#if defined(SHOW_ERROR_MESSAGE) && SHOW_ERROR_MESSAGE
+#include "ErrorMessage.h"
+#endif
+
+#if defined(OPTIMIZE_LOADHEAPLIST) && OPTIMIZE_LOADHEAPLIST
+#pragma warn -8070
+#endif
+
 #pragma warning(disable:4786)
 //=====================================================================
 //THeapListDataクラス
@@ -92,8 +109,31 @@
 //　　　　　　　　　↑不定数　　　　　　　　↑不定数
 //
 //---------------------------------------------------------------------
+#if defined(OPTIMIZE_LOADHEAPLIST) && OPTIMIZE_LOADHEAPLIST
+__declspec(naked) int __cdecl CompareHeapListData(const void *elem1, const void *elem2)
+{
+	__asm
+	{
+		#define offsetof_THeapListData_heapListAddress 16
+
+		mov     ecx, dword ptr [esp + 4]
+		mov     edx, dword ptr [esp + 8]
+		mov     ecx, dword ptr [ecx + offsetof_THeapListData_heapListAddress]
+		mov     edx, dword ptr [edx + offsetof_THeapListData_heapListAddress]
+		xor     eax, eax
+		cmp     ecx, edx
+		seta    al
+		sbb     eax, 0
+		ret
+
+		#undef offsetof_THeapListData_heapListAddress
+	}
+}
+//---------------------------------------------------------------------
+#endif
 void TProcessCtrl::LoadHeapList(void)
 {
+#if !defined(OPTIMIZE_LOADHEAPLIST) || !OPTIMIZE_LOADHEAPLIST
 
  DWORD PHandle = entry.th32ProcessID;
  HANDLE Snapshot  //ヒープリスト列挙用スナップショット
@@ -146,6 +186,41 @@
  CloseHandle( Snapshot );
 
 
+#else
+	HANDLE hSnapshot;
+
+	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPHEAPLIST, entry.th32ProcessID);
+	if (hSnapshot != INVALID_HANDLE_VALUE)
+	{
+		HEAPLIST32 hl;
+
+		hl.dwSize = sizeof(HEAPLIST32);
+		if (Heap32ListFirst(hSnapshot, &hl))
+		{
+			HEAPENTRY32 he;
+
+			he.dwSize = sizeof(HEAPENTRY32);
+			heapList.clear();
+			do
+			{
+				THeapListData heapListData;
+
+				heapListData.heapList = hl;
+				if (Heap32First(&he, hl.th32ProcessID, heapListData.heapList.th32HeapID))
+				{
+					heapListData.heapListAddress = he.dwAddress & ~(4096 - 1);
+					heapListData.heapListSize = 4096 - 1;
+					heapList.push_back(heapListData);
+				}
+			} while (Heap32ListNext(hSnapshot, &hl));
+			if (!heapList.empty())
+			{
+				qsort(heapList.begin(), heapList.size(), sizeof(THeapListData), CompareHeapListData);
+			}
+		}
+		CloseHandle(hSnapshot);
+	}
+#endif
 }
 //---------------------------------------------------------------------
 //対象プロセスのモジュール一覧を所得
@@ -154,6 +229,9 @@
 //	・すでにAttachを行っていること
 //	　（というか、Attach()内から呼び出される）
 //---------------------------------------------------------------------
+#if defined(ADD_ENTRY_MODULE) && ADD_ENTRY_MODULE
+#include "AddEntryModule.c"
+#endif
 void TProcessCtrl::LoadModuleList(void)
 {
 
@@ -174,6 +252,9 @@
     for(map<DWORD, MODULEENTRY32>::iterator it=ModuleMap.begin();
     		it!=ModuleMap.end(); it++)
 		moduleList.push_back( (*it).second );
+#if defined(ADD_ENTRY_MODULE) && ADD_ENTRY_MODULE
+    AddEntryModule(&moduleList, entry.th32ProcessID);
+#endif
  }
 
  CloseHandle( Snapshot );
@@ -269,6 +350,9 @@
 //	・発見したプロセス名を、ProcessNameに上書きします(大文字小文字の対応)
 //	・プロセス名はワイルドカード指定が可能です。
 //---------------------------------------------------------------------
+#if defined(PROCESS_MONITOR) && PROCESS_MONITOR
+#include "TProcessCtrl_FindProcess.c"
+#else
 unsigned long TProcessCtrl::FindProcess(string *ProcessName, PROCESSENTRY32 *Entry)
 {
  HANDLE Snapshot //プロセス列挙用スナップショット
@@ -295,6 +379,7 @@
  CloseHandle( Snapshot );
  return 1;	//失敗
 }
+#endif
 //---------------------------------------------------------------------
 //実行ファイル名を元に、対象プロセスを所得する
 //
@@ -404,7 +489,15 @@
 	if(strD.Upper((string)VIt->szModule)==Name)
 		return VIt;
  }
+#if !defined(FIX_GET_MODULE_FROM_NAME) || !FIX_GET_MODULE_FROM_NAME
  LoadModuleList();	//再リストアップ
+#else
+ // 再リストアップ
+ if (entry.th32ProcessID != 0)
+	LoadModuleList();
+ else
+	Attach();
+#endif
 
  VIt  = moduleList.begin();
  VEnd = moduleList.end();
