--- spal60sr\src\TSSGCtrl\SSBundleList.original.cpp	Sun Apr  6 21:43:38 2003
+++ spal60sr\src\TSSGCtrl\SSBundleList.cpp	Sun Apr  6 21:43:38 2003
@@ -1,5 +1,22 @@
 #include "SSBundleList.h"
 
+#define ERRORSKIP_SUPPORT 1
+
+#if LOCAL_MEMORY_SUPPORT
+#if IO_FEP_SUPPORT
+void __stdcall TSSGSubject_CheckFEPParam(TSSGSubject *_this, const string *s);
+BOOLEAN __stdcall TSSGCtrl_OneRead_with_CheckLocalMemory_CheckIO_FEP(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size, const string &AddressStr);
+BOOLEAN __stdcall TSSGCtrl_OneWrite_with_CheckLocalMemory_CheckIO_FEP(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size, const string &AddressStr);
+#else
+BOOLEAN __stdcall TSSGCtrl_OneRead_with_CheckLocalMemory(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size, const string &AddressStr);
+BOOLEAN __stdcall TSSGCtrl_OneWrite_with_CheckLocalMemory(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size, const string &AddressStr);
+#endif
+#endif
+
+#if ERRORSKIP_SUPPORT
+#define AT_ERRORSKIP 0x2000
+#endif
+
 //---------------------------------------------------------------------
 //「初期設定関数」
 //
@@ -13,6 +30,10 @@
  vector<string> tmpV;
  
  SSGC.strD.List(code+SSGC.GetEndWith(this), ",", &tmpV, strD::etTRIM+strD::dtESCAPE);
+#if IO_FEP_SUPPORT
+ if (tmpV.size() >= 7)
+	TSSGSubject_CheckFEPParam(this, &tmpV[6]);
+#endif
  tmpV.resize(6);	//規定数に
  
  addressStr = tmpV[0];
@@ -58,14 +79,26 @@
  Setting(SSGC);
  
  TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
  if(( SHandle=SSGC.processCtrl.Open(PROCESS_VM_READ) )==NULL)
 	return ssgCtrl::reOPEN_ERROR;	//プロセスのオープンエラー
+#else
+ SHandle = SSGC.processCtrl.Open(PROCESS_VM_READ);
+#endif
 
+#if !SUBJECT_STATUS
  if(!SSGC.IsEnabled(this)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
+#else
+ if(!SSGC.IsEnabled(this, TRUE)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
+#endif
 
 
  //オフセット用のアドレスには、[replace]等の属性を付けない
+#if !SUBJECT_STATUS
  unsigned long Address = (isOffset)?SSGC.GetAddress(this, addressStr, 0):0;
+#else
+ unsigned long Address = (isOffset) ? (unsigned long)(address = (const BYTE *)SSGC.GetAddress(this, addressStr, 0)) : 0;
+#endif
 
  if(size==0)	//Setting()中ではファイルが開けなかった
 	return ssgCtrl::reOPTION_ERROR;	//リストファイルがない！
@@ -81,7 +114,13 @@
 	
 	ThisAddress = Address+SSGC.GetAddress(this, ListFile->at(i));
 
+#if !LOCAL_MEMORY_SUPPORT
 	if(!SSGC.OneRead(this, SHandle, ThisAddress, &Val, size)) 
+#elif !IO_FEP_SUPPORT
+	if (!TSSGCtrl_OneRead_with_CheckLocalMemory(&SSGC, this, SHandle, ThisAddress, &Val, size, ListFile->at(i)))
+#else
+	if (!TSSGCtrl_OneRead_with_CheckLocalMemory_CheckIO_FEP(&SSGC, this, SHandle, ThisAddress, &Val, size, ListFile->at(i)))
+#endif
 		return ssgCtrl::reACCESS_ERROR;	//エラーなら1を返す
 	
 	TotalVal += Val;
@@ -105,14 +144,22 @@
  Setting(SSGC);
 
  TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
  if(( SHandle=SSGC.Open(this, PROCESS_VM_READ|PROCESS_VM_WRITE|PROCESS_VM_OPERATION) )==NULL)
 	return ssgCtrl::reOPEN_ERROR;	//プロセスのオープンエラー
+#else
+ SHandle = SSGC.Open(this, PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION);
+#endif
 
  if(!SSGC.IsEnabled(this)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
 
 
  //オフセット用のアドレスには、[replace]等の属性を付けない
+#if !SUBJECT_STATUS
  unsigned long Address = (isOffset)?SSGC.GetAddress(this, addressStr, 0):0;
+#else
+ unsigned long Address = (isOffset) ? (unsigned long)(address = (const BYTE *)SSGC.GetAddress(this, addressStr, 0)) : 0;
+#endif
 
  vector<string> *ListFile = SSGC.GetSSGDataFile(this, chainFileName, ".CHN");
  if(ListFile==NULL) return ssgCtrl::reOPTION_ERROR;	//チェインファイルがない！
@@ -126,7 +173,16 @@
 
 	ThisAddress = Address+SSGC.GetAddress(this, ListFile->at(i));
 
+#if !LOCAL_MEMORY_SUPPORT
 	if(!SSGC.OneWrite(this, SHandle, ThisAddress, &Val, size))	//エラーなら
+#elif !IO_FEP_SUPPORT
+	if (!TSSGCtrl_OneWrite_with_CheckLocalMemory(&SSGC, this, SHandle, ThisAddress, &Val, size, ListFile->at(i)))	//エラーなら
+#else
+	if (!TSSGCtrl_OneWrite_with_CheckLocalMemory_CheckIO_FEP(&SSGC, this, SHandle, ThisAddress, &Val, size, ListFile->at(i)))	//エラーなら
+#endif
+#if ERRORSKIP_SUPPORT
+	if (!SSGC.GetAttribute(this, AT_ERRORSKIP))
+#endif
  		return ssgCtrl::reACCESS_ERROR;
  	
  }
