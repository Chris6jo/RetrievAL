--- SSCalc.original.cpp	Sun Apr  6 21:43:52 2003
+++ SSCalc.cpp	Sun Apr  6 21:43:52 2003
@@ -1,6 +1,13 @@
 #include "SSCalc.h"
 #include "BitOperation.h"
 
+#define LOCAL_MEMORY_SUPPORT 1
+#define MIN_MAX_SUPPORT      1
+
+#if MIN_MAX_SUPPORT
+#include "intrinsic.h"
+#endif
+
 //---------------------------------------------------------------------
 //「初期設定関数」
 //
@@ -12,7 +19,11 @@
  if(isSeted) return;
  
  vector<string> tmpV;
+#if !SUBJECT_STRING_TABLE
  SSGC.strD.List(code+SSGC.GetEndWith(this), ",", &tmpV, strD::etTRIM);
+#else
+ SSGC.strD.List((string&)code + SSGC.GetEndWith(this), ",", &tmpV, strD::etTRIM);
+#endif
  tmpV.resize(5);	//規定数に
 
  //属性を適用
@@ -29,13 +40,41 @@
 		else						size=1;
 		isUnsigned = true;
 	}else{
+#if !MIN_MAX_SUPPORT
         if(max<=0xFF && min>=-0xFF)         size=1;
 		else if(max<=0xFFFF && min>=-0xFFFF)size=2;
 		else 							    size=4;
+#else
+		if (max <= SHRT_MAX && min >= SHRT_MIN &&
+			(tmpV[1].length() != 3 || (*(LPDWORD)tmpV[1].begin() != BSWAP32('min\0') && *(LPDWORD)tmpV[1].begin() != BSWAP32('max\0'))) &&
+			(tmpV[2].length() != 3 || (*(LPDWORD)tmpV[2].begin() != BSWAP32('max\0') && *(LPDWORD)tmpV[2].begin() != BSWAP32('min\0'))))
+		{
+			size = (max <= CHAR_MAX && min >= CHAR_MIN) ? 1 : 2;
+		}
+		else
+		{
+			size = 4;
+		}
+#endif
 		isUnsigned = false;
 	}
  }else isUnsigned = (tmpV[3]=="unsigned");
 
+#if MIN_MAX_SUPPORT
+ if (size > 4)
+	size = 4;
+ if (tmpV[1].length() == 3)
+	if (*(LPDWORD)tmpV[1].begin() == BSWAP32('min\0'))
+		min = isUnsigned ? 0 : (long)LONG_MIN >> ((4 - size) * 8);
+	else if (*(LPDWORD)tmpV[1].begin() == BSWAP32('max\0'))
+		min = (isUnsigned ? ULONG_MAX : LONG_MAX) >> ((4 - size) * 8);
+ if (tmpV[2].length() == 3)
+	if (*(LPDWORD)tmpV[2].begin() == BSWAP32('min\0'))
+		max = isUnsigned ? 0 : (long)LONG_MIN >> ((4 - size) * 8);
+	else if (*(LPDWORD)tmpV[2].begin() == BSWAP32('max\0'))
+		max = (isUnsigned ? ULONG_MAX : LONG_MAX) >> ((4 - size) * 8);
+#endif
+
  isBigEndian = (tmpV[4]=="big_e");
 
 
@@ -64,14 +103,25 @@
  Setting(SSGC);
 
  TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
  if(( SHandle=SSGC.Open(this, PROCESS_VM_READ) )==NULL)
+#else
+ if ((SHandle = SSGC.Open(this, PROCESS_VM_READ, addressStr.c_str())) == NULL)
+#endif
 	return ssgCtrl::reOPEN_ERROR;	//プロセスのオープンエラー
 
+#if !SUBJECT_STATUS
  if(!SSGC.IsEnabled(this)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
+#else
+ if(!SSGC.IsEnabled(this, TRUE)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
+#endif
 
 
  //属性を適用
  unsigned long Address = SSGC.GetAddress(this, addressStr);
+#if SUBJECT_STATUS
+ address = (const BYTE *)Address;
+#endif
 
  unsigned long Num = 0;  //初期化
 
@@ -101,7 +151,11 @@
  Setting(SSGC);
 
  TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
  if(( SHandle=SSGC.Open(this, PROCESS_VM_READ|PROCESS_VM_WRITE|PROCESS_VM_OPERATION) )==NULL)
+#else
+ if ((SHandle = SSGC.Open(this, PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, addressStr.c_str())) == NULL)
+#endif
 	return ssgCtrl::reOPEN_ERROR;	//プロセスのオープンエラー
 
  if(!SSGC.IsEnabled(this)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
@@ -109,6 +163,9 @@
 
  //属性を適用
  unsigned long Address = SSGC.GetAddress(this, addressStr);
+#if SUBJECT_STATUS
+ address = (const BYTE *)Address;
+#endif
 
  unsigned long Num = ((TSSArgLong*)Arg)->GetValue();
  Num = SSGC.CheckIO_FEP(this, Num, ssgCtrl::ftTO_OUTPUT);
