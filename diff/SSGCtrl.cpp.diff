--- spal60sr\src\TSSGCtrl\SSGCtrl.original.cpp	Mon May 26 13:47:18 2003
+++ spal60sr\src\TSSGCtrl\SSGCtrl.cpp	Mon May 26 13:47:18 2003
@@ -23,6 +23,102 @@
 #include "SSBundleFloatCalc.h"
 #include "SSSplit.h"
 
+#define UNICODE_SUPPORT               1
+#define ADDRESS_NAMING_FEP_SUPPORT    1
+#define FIX_ADDRESS_NAMING_FROM_FLOAT 1
+#define ADDITIONAL_TAGS               1
+#define FIX_TOGGLE_BYTE_ARRAY         1
+#define ALLOCATE_SUPPORT              1
+#define FIX_GET_SSG_DATA_FILE         1
+#define FIX_REPEAT                    1
+#define FIX_REMOVE_SPACE              1
+#define FIX_BYTE_ARRAY_FIND           1
+#define ERRORSKIP_SUPPORT             1
+#define FIX_DGRID                     1
+#define ADDRESS_NAMING_FMT_SUPPORT    1
+#define IMAGE_SIZE                    1
+#define NOCACHED_MEMORY_LIST          1
+#define FIX_DOUBLE_LIST               1
+#define COMMON_LIST                   1
+#define LIST_PARSER                   1
+#define FIX_FORMAT                    1
+
+#if FIX_REPEAT
+#include <stdlib.h>
+#ifndef _countof
+#define _countof(_Array) (sizeof(_Array) / sizeof((_Array)[0]))
+#endif
+#define RT_FORMAT 0x20
+#endif
+
+#if FIX_BYTE_ARRAY_FIND
+#include <limits.h>
+#ifndef SIZE_MAX
+#ifdef _WIN64
+#define SIZE_MAX _UI64_MAX
+#else
+#define SIZE_MAX UINT_MAX
+#endif
+#endif
+#endif
+
+#if UNICODE_SUPPORT            || \
+    FIX_TOGGLE_BYTE_ARRAY      || \
+    OPTIMIZE_STRINGDIVISION    || \
+    FIX_LOOP_BYTE_ARRAY        || \
+    FIX_GET_SSG_DATA_FILE      || \
+    FIX_REPEAT                 || \
+    FIX_REMOVE_SPACE           || \
+    FIX_BYTE_ARRAY_FIND        || \
+    LOCAL_MEMORY_SUPPORT       || \
+    ADDRESS_NAMING_FMT_SUPPORT
+#include "intrinsic.h"
+#endif
+
+#if UNICODE_SUPPORT || FIX_PARSER
+extern HANDLE hHeap;
+#endif
+
+#if ADDITIONAL_TAGS
+#include "AdditionalTags.cpp"
+
+#if ALLOCATE_SUPPORT
+#ifndef TYPEDEF_PROCESSMEMORYBLOCK
+#define TYPEDEF_PROCESSMEMORYBLOCK
+typedef struct {
+	ULARGE_INTEGER Id;
+	LPVOID         MemoryBlock;
+} PROCESSMEMORYBLOCK, *PPROCESSMEMORYBLOCK;
+#endif
+
+extern size_t             nNumberOfProcessMemory;
+extern PROCESSMEMORYBLOCK *lpProcessMemory;
+#endif	// ALLOCATE_SUPPORT
+#endif	// ADDITIONAL_TAGS
+
+#if ERRORSKIP_SUPPORT
+#include "MainUnit.h"
+extern TMainForm *MainForm;
+#define AT_ERRORSKIP 0x2000
+#endif
+
+#if FIX_DGRID
+#include "SSGSubjectProperty.h"
+#endif
+
+#if IMAGE_SIZE
+extern LPDWORD lpdwImageSize;
+extern size_t  nNumberOfImageSize;
+#endif
+
+#if REPEAT_INDEX
+DWORD RepeatDepth;
+#endif
+
+#if FORMAT_NAME_STRING
+#include <float.h>
+#endif
+
 //---------------------------------------------------------------------
 //初期化とお掃除
 //---------------------------------------------------------------------
@@ -96,6 +192,50 @@
  dataFileMap.clear();
  LockClear();
 
+#if FIX_DGRID
+	ClearSubjectProperty();
+#endif
+
+#if ALLOCATE_SUPPORT
+	if (lpProcessMemory)
+	{
+		if (nNumberOfProcessMemory)
+		{
+			HANDLE hProcess;
+			size_t i;
+
+			hProcess = processCtrl.Open(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION);
+			if (hProcess)
+			{
+				i = nNumberOfProcessMemory;
+				do
+				{
+					if (lpProcessMemory[--i].Protect && lpProcessMemory[i].Address)
+						VirtualFreeEx(hProcess, lpProcessMemory[i].Address, 0, MEM_RELEASE);
+				} while (i);
+				CloseHandle(hProcess);
+			}
+			i = nNumberOfProcessMemory;
+			do
+			{
+				if (!lpProcessMemory[--i].Protect && lpProcessMemory[i].Address)
+					HeapFree(hHeap, 0, lpProcessMemory[i].Address);
+			} while (i);
+			nNumberOfProcessMemory = 0;
+		}
+		HeapFree(hHeap, 0, lpProcessMemory);
+		lpProcessMemory = NULL;
+	}
+#endif
+
+#if IMAGE_SIZE
+	nNumberOfImageSize = 0;
+	if (lpdwImageSize)
+	{
+		HeapFree(hHeap, 0, lpdwImageSize);
+		lpdwImageSize = NULL;
+	}
+#endif
 }
 //---------------------------------------------------------------------
 //「保持しているロック情報の解放関数」
@@ -120,6 +260,9 @@
 //---------------------------------------------------------------------
 void TSSGCtrl::ReadSSG(vector<string> &SSGFile)
 {
+#if SUBJECT_STRING_TABLE
+ SubjectStringTable.clear();
+#endif
  script.Clear();
  processNameVec.clear();
 
@@ -133,6 +276,9 @@
  stack<TSSDir*> ParentStack;
  ParentStack.push(rootSubject);
 
+#if REPEAT_INDEX
+ RepeatDepth = 0;
+#endif
  EnumReadSSG(SSGFile, &ParentStack, NULL);
 
  attributeSelector.EndElementCheck();
@@ -146,8 +292,15 @@
 //	・対象がADJファイルの場合は、ADJElemに対応する
 //	　TDialogAdjustmentAttributeのポインタを渡して下さい。（それ以外はNULL）
 //---------------------------------------------------------------------
+#if FIX_PARSER
+#include "ReplaceDefine.c"
+#endif
+#if !REPEAT_INDEX
 void TSSGCtrl::EnumReadSSG(vector<string> &SSGFile, stack<TSSDir*> *ParentStack,
 	TDialogAdjustmentAttribute *ADJElem)
+#else
+void TSSGCtrl::EnumReadSSG(vector<string> &SSGFile, stack<TSSDir *> *ParentStack, TDialogAdjustmentAttribute *ADJElem, DWORD RepeatIndex/* = 0*/, DWORD ParentRepeat/* = MAXDWORD*/)
+#endif
 {
  set<string> ADJSubjectSet;		//ADJ用項目セット
  if(ADJElem!=NULL){
@@ -199,6 +352,15 @@
 		}
 
         SSGS->Setting(*this);
+#if REPEAT_INDEX
+		TSSGSubjectProperty *prop = GetSubjectProperty(SSGS);
+		if (prop)
+		{
+			prop->RepeatDepth  = RepeatDepth;
+			prop->RepeatIndex  = RepeatIndex;
+			prop->ParentRepeat = ParentRepeat;
+		}
+#endif
 	}else if(tmpS=="[back"){
 		if( ParentStack->size()>1 ){
 			TDirAttribute NewAElem;
@@ -217,6 +379,9 @@
 		}
 	}else if(tmpS=="[replace"){
 		TReplaceAttribute *NewAElem = new TReplaceAttribute();
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		NewAElem->Setting(strD, LineS.c_str());
 
         vector<string> *tmpL;
@@ -229,12 +394,19 @@
 		attributeSelector.AddElement(NewAElem);
 
 		//再帰
+#if !REPEAT_INDEX
 		EnumReadSSG(*tmpL, ParentStack, ADJElem);
+#else
+		EnumReadSSG(*tmpL, ParentStack, ADJElem, RepeatIndex, ParentRepeat);
+#endif
 		{//帰ってきたので、[replace]属性を外す
         	TReplaceAttribute AElem;
 			attributeSelector.EraseElement(&AElem);
         }
 	}else if(tmpS=="[size"){	//アクセスサイズ強制指定命令
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		long tmpI = TStringDivision::ToLongDef(LineS, -1);
 		if(tmpI>=0){
             //[size]属性を付加
@@ -243,6 +415,9 @@
 			attributeSelector.PushElement(NewAElem);
 		}
 	}else if(tmpS=="[adjustment"){	//[adjustment]属性を付加
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		TAdjustmentAttribute *NewAElem = TSSGCtrl::MakeAdjustmentClass(strD.Half(&LineS, ",", 0));
         if(NewAElem!=NULL){
 	        NewAElem->Setting(*this, LineS.c_str());
@@ -255,6 +430,9 @@
 		TCRCAdjustmentAttribute NewAElem; //補正属性であれば、どれでもよい
 		attributeSelector.PopElement(&NewAElem);
 	}else if(tmpS=="[funnel"){	//[funnel]属性を付加
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		TFunnelAttribute *NewAElem = new TFunnelAttribute();
 		NewAElem->Setting(LineS.c_str());
 		attributeSelector.PushElement(NewAElem);
@@ -262,13 +440,64 @@
 		TFunnelAttribute NewAElem;
 		attributeSelector.PopElement(&NewAElem);
 	}else if(tmpS=="[repeat"){	//繰り返し書式発動！
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
+#if !REPEAT_INDEX
 		vector<string> tmpV( ReadSSRFile(LineS) );
 		if(!tmpV.empty()){
 			//現在の設定(ReadStruct)を引き継ぎながら、展開したファイルへ再帰
 			EnumReadSSG(tmpV, ParentStack, ADJElem);
 		}
+#else
+		vector<DWORD>  indices;
+		vector<string> tmpV(ReadSSRFile(LineS, indices));
+
+		if (!tmpV.empty())
+		{
+			if (!indices.empty())
+			{
+				DWORD                    parent;
+				TSSGSubjectProperty      *prop;
+				vector<string>           SSGFile;
+				vector<DWORD>::iterator  repeat;
+				vector<string>::iterator it;
+
+				prop = GrowSubjectProperty(&parent);
+				if (prop)
+				{
+					prop->RepeatDepth  = RepeatDepth;
+					prop->RepeatIndex  = RepeatIndex;
+					prop->ParentRepeat = ParentRepeat;
+				}
+				SSGFile.resize(tmpV.size() / indices.size());
+				RepeatDepth++;
+				repeat = indices.begin();
+				it = tmpV.begin();
+				do
+				{
+					vector<string>::iterator dest;
+
+					dest = SSGFile.begin();
+					do
+					{
+						*(dest++) = *(it++);
+					} while (dest != SSGFile.end());
+					EnumReadSSG(SSGFile, ParentStack, ADJElem, *(repeat++), parent);
+				} while (it < tmpV.end());
+				RepeatDepth--;
+			}
+			else
+			{
+				EnumReadSSG(tmpV, ParentStack, ADJElem, RepeatIndex, ParentRepeat);
+			}
+		}
+#endif
 	}else if(tmpS=="[io_fep"){	//[io_fep]属性を付加
 		TIO_FEPAttribute *NewAElem = new TIO_FEPAttribute(); //io_fep
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
         NewAElem->Setting(strD, LineS.c_str());
 		attributeSelector.PushElement(NewAElem);
 	}else if(tmpS=="[/io_fep"){	//[io_fep]属性を除去
@@ -276,6 +505,9 @@
 		attributeSelector.PopElement(&NewAElem);
 	}else if(tmpS=="[e_with"){	//[e_with]属性を付加
 		TEndWithAttribute *NewAElem = new TEndWithAttribute(); //e_with
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		NewAElem->Setting(LineS.c_str());
 		attributeSelector.PushElement(NewAElem);
 	}else if(tmpS=="[/e_with"){	//[e_with]属性を除去
@@ -283,6 +515,9 @@
 		attributeSelector.PopElement(&NewAElem);
 	}else if(tmpS=="[enabled"){	//[enabled]属性を付加
 		TEnabledAttribute *NewAElem = new TEnabledAttribute(); //enabled
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		NewAElem->Setting(LineS.c_str());
 		attributeSelector.AddElement(NewAElem);
 	}else if(tmpS=="[/enabled"){	//[enabled]属性を除去
@@ -290,6 +525,9 @@
 		attributeSelector.EraseElement(&NewAElem);
 	}else if(tmpS=="[adjust_check"){	//[adjust_check]属性を付加
 		TAdjustCheckAttribute *NewAElem = new TAdjustCheckAttribute();
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		NewAElem->Setting(strD, LineS.c_str());
 		attributeSelector.PushElement(NewAElem);
 	}else if(tmpS=="[/adjust_check"){	//[adjust_check]属性を除去
@@ -297,6 +535,9 @@
 		attributeSelector.PopElement(&NewAElem);
 	}else if(tmpS=="[child_rw"){	//[child_rw]属性を付加
 		TChildRWAttribute *NewAElem = new TChildRWAttribute(); //child_rw
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		NewAElem->Setting(strD, LineS.c_str());
 		attributeSelector.PushElement(NewAElem);
 	}else if(tmpS=="[/child_rw"){	//[child_rw]属性を除去
@@ -304,6 +545,9 @@
 		attributeSelector.PopElement(&NewAElem);
 	}else if(tmpS=="[caution"){	//[caution]属性を付加
 		TCautionAttribute *NewAElem = new TCautionAttribute(); //caution
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		NewAElem->Setting(LineS.c_str());
 		attributeSelector.PushElement(NewAElem);
 	}else if(tmpS=="[/caution"){	//[caution]属性を除去
@@ -317,11 +561,17 @@
 			if(*VIt=="[/involve]")break;
 			tmpV.push_back(*VIt);
 		}
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		FName += strD.Trim(LineS);
 		FName += ".ssl";
 		SetSSGDataFile(&tmpV, FName, true);
         if(VIt==VEnd) return;  //[/involve]が存在しない
 	}else if(tmpS=="[note"){
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		bool IsMemoWordWrap = (strD.Trim(LineS)=="wordwrap");
 
 		vector<string> tmpV;
@@ -338,15 +588,35 @@
 			ADJElem->SetMemo(tmpV);
 		}
         if(VIt==VEnd) return;  //[/note]が存在しない
+#if !FIX_PARSER
 	}else if(tmpS=="[process"){		processNameVec.push_back(LineS);
 	}else if(tmpS=="[title"){		script.SetDistinction("title"	, LineS.c_str());
 	}else if(tmpS=="[maker"){		script.SetDistinction("maker"	, LineS.c_str());
 	}else if(tmpS=="[creator"){		script.SetDistinction("creator"	, LineS.c_str());
 	}else if(tmpS=="[distinction"){		
+#else
+	} else if (tmpS == "[process") {
+		ReplaceDefine(&attributeSelector, &LineS);
+		processNameVec.push_back(LineS);
+	} else if (tmpS == "[title") {
+		ReplaceDefine(&attributeSelector, &LineS);
+		script.SetDistinction("title", LineS.c_str());
+	} else if (tmpS == "[maker") {
+		ReplaceDefine(&attributeSelector, &LineS);
+		script.SetDistinction("maker", LineS.c_str());
+	} else if (tmpS == "[creator") {
+		ReplaceDefine(&attributeSelector, &LineS);
+		script.SetDistinction("creator", LineS.c_str());
+	} else if (tmpS == "[distinction") {
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		tmpS = strD.Half(&LineS, "=", 0, strD::dtESCAPE|strD::etREPLACE|strD::etTRIM);
 		if(tmpS != "=") script.SetDistinction(tmpS.c_str(), LineS.c_str());
 	}else if(ADJSubjectSet.find(tmpS)!=ADJSubjectSetEnd){
 		TSSGSubject *SSGS;
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		if(tmpS=="[calc"){
 			tmpS = strD.Half(&LineS, ",", 1);
 			SSGS = new TSSCalc();
@@ -363,12 +633,29 @@
 		SSGS->Setting(*this);
         ParentStack->top()->GetChildVec()->push_back( SSGS );
         SSGS->SetAttribute( attributeSelector.GetNowAtteributeVec() );
+#if REPEAT_INDEX
+		TSSGSubjectProperty *prop = GetSubjectProperty(SSGS);
+		if (prop)
+		{
+			prop->RepeatDepth  = RepeatDepth;
+			prop->RepeatIndex  = RepeatIndex;
+			prop->ParentRepeat = ParentRepeat;
+		}
+#endif
 	}else if(tmpS=="[val"){
 		if(ADJElem==NULL) continue;
+#if FIX_PARSER
+		ReplaceDefine(&attributeSelector, &LineS);
+#endif
 		ADJElem->SetValStr( LineS.c_str() );
 	}else if(tmpS=="[/script"){
 		break;
 	}
+#if ADDITIONAL_TAGS
+	else{
+		AdditionalTags(this, ParentStack->top(), tmpS, LineS);
+	}
+#endif
  }
 
 }
@@ -489,6 +776,118 @@
 //	・まだ一度も開かれていないファイルなら、開きます。
 //	・拡張子には'.'を含める
 //---------------------------------------------------------------------
+#if FIX_GET_SSG_DATA_FILE
+void __stdcall FixGetSSGDataFile(string &FileName)
+{
+	char   *begin, *end;
+	size_t length;
+
+	// it do not checking multibyte,
+	// because space is not the lead and tail byte of codepage 932.
+
+	begin = FileName.begin();
+	while (__intrinsic_isspace_without_return(*begin))
+		begin++;
+	end = FileName.end() - 1;
+	while (end > begin && __intrinsic_isspace_without_return(*end))
+		end--;
+	if (++end == FileName.end() && begin == FileName.begin())
+		return;
+	length = end - begin;
+	if (begin != FileName.begin())
+		memcpy(begin, FileName.begin(), length);
+	FileName.resize(length);
+}
+//---------------------------------------------------------------------
+#endif
+#if LOCAL_MEMORY_SUPPORT
+BOOL __fastcall TSSGCtrl_IsRemoteProcess(LPCSTR p)
+{
+	if (p)
+	{
+		char c = *(p++);
+		while (__intrinsic_isspace(c))
+			c = *(p++);
+		if (c == '_')
+			do
+			{
+				c = *(p++);
+			} while (__intrinsic_isspace(c));
+		if (c == 'L')
+		{
+			c = *p;
+			if (__intrinsic_isspace(c) || c == '{')
+				return FALSE;
+		}
+	}
+	return TRUE;
+}
+//---------------------------------------------------------------------
+HANDLE __stdcall TSSGCtrl_OpenProcess(TProcessCtrl *processCtrl, DWORD Mode, LPCSTR addressStr)
+{
+	return TSSGCtrl_IsRemoteProcess(addressStr) ?
+		processCtrl->Open(Mode) :
+		::GetCurrentProcess();
+}
+//---------------------------------------------------------------------
+unsigned long __stdcall TSSGCtrl_Read_with_CheckLocalMemory(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD *Address, vector<TProcessAccessElementBase*> &AEVec, const string &AddressStr)
+{
+	return _this->Read(SSGS, TSSGCtrl_IsRemoteProcess(AddressStr.c_str()) ? ProcessHandle : ::GetCurrentProcess(), Address, AEVec);
+}
+//---------------------------------------------------------------------
+unsigned long __stdcall TSSGCtrl_Write_with_CheckLocalMemory(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD *Address, vector<TProcessAccessElementBase*> &AEVec, const string &AddressStr)
+{
+	return _this->Write(SSGS, TSSGCtrl_IsRemoteProcess(AddressStr.c_str()) ? ProcessHandle : ::GetCurrentProcess(), Address, AEVec);
+}
+//---------------------------------------------------------------------
+long __stdcall TSSGCtrl_Compare_with_CheckLocalMemory(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD *Address, vector<TProcessAccessElementBase*> &AEVec, const string &AddressStr)
+{
+	return _this->Compare(SSGS, TSSGCtrl_IsRemoteProcess(AddressStr.c_str()) ? ProcessHandle : ::GetCurrentProcess(), Address, AEVec);
+}
+//---------------------------------------------------------------------
+BOOLEAN __stdcall TSSGCtrl_OneRead_with_CheckLocalMemory(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size, const string &AddressStr)
+{
+	return _this->OneRead(SSGS, TSSGCtrl_IsRemoteProcess(AddressStr.c_str()) ? ProcessHandle : ::GetCurrentProcess(), Address, Data, Size);
+}
+//---------------------------------------------------------------------
+BOOLEAN __stdcall TSSGCtrl_OneWrite_with_CheckLocalMemory(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size, const string &AddressStr)
+{
+	return _this->OneWrite(SSGS, TSSGCtrl_IsRemoteProcess(AddressStr.c_str()) ? ProcessHandle : ::GetCurrentProcess(), Address, Data, Size);
+}
+//---------------------------------------------------------------------
+#endif
+#if FIX_REPEAT || FIX_REMOVE_SPACE || NOCACHED_MEMORY_LIST
+#include "TrimString.c"
+#endif
+#if NOCACHED_MEMORY_LIST
+BOOL __fastcall TSSGCtrl_GetSSGDataFile_CheckNocacheParam(vector<string> *tmpV)
+{
+	if (tmpV->size() >= 8)
+	{
+		char *p = (*tmpV)[7].begin();
+		while (__intrinsic_isspace(*p))
+			p++;
+		size_t length = (*tmpV)[7].end() - p;
+		if (length >= 7)
+		{
+			while (length >= 7 && __intrinsic_isspace(*(p + length - 1)))
+				length--;
+			if (length == 7 && *(LPDWORD)p == BSWAP32('noca') && *(LPWORD)(p + 4) == BSWAP16('ch') && *(p + 6) == 'e')
+				return TRUE;
+		}
+	}
+	return FALSE;
+}
+//---------------------------------------------------------------------
+void __cdecl TSSGCtrl_GetSSGDataFile_FixSetSSGDataFile(TSSGCtrl *_this, vector<string> *Data, const string& FileName, BOOL IsNocache)
+{
+	if (!IsNocache)
+		_this->SetSSGDataFile(Data, FileName, false);
+	else
+		(*_this->GetDataFileMap())[_this->strD.Lower(FileName)][""] = *Data;
+}
+//---------------------------------------------------------------------
+#endif
 vector<string> * TSSGCtrl::GetSSGDataFile(TSSGSubject *SSGS,
     string FName, string DefaultExt, string *CurrentDir)
 {
@@ -497,36 +896,96 @@
  string GroupName;
  map <string, map<string, vector<string> > >:: iterator  FNameIt;
  if(FName[0]=='_'){ //抽出リスト
+#if NOCACHED_MEMORY_LIST
+	BOOL IsNocache = FALSE;
+#endif
     vector<string> tmpV;
     while(1){
 	    strD.List(FName, "/", &tmpV);
+#if !NOCACHED_MEMORY_LIST
     	tmpV.resize(6);
+#else
+		IsNocache = TSSGCtrl_GetSSGDataFile_CheckNocacheParam(&tmpV);
+		tmpV.resize(7);
+#endif
 	    //_mem/0x400000/8/20/00/Error!
     	//_mem/アドレス/最大文字数/行数/ステップサイズ/終端バイト列/エラー時の代替え文字列
 	    unsigned long Address, StrSize, RowSize, ReadSize, StepSize;
 		//オプション解析
 	    if(SSGS==NULL) SSGS = rootSubject;
     	Address = GetAddress(SSGS, tmpV[1]);
+#if !FIX_DOUBLE_LIST
         if(Address==0) break;   //アドレス所得エラー
+#else
+		if (Address == 0)
+		{
+			tmpV.clear();
+			break;
+		}
+#endif
 
+#if !LIST_PARSER
 	    StrSize = TStringDivision::ToULongDef(tmpV[2], 1);
     	RowSize = TStringDivision::ToULongDef(tmpV[3], 1);
     	StepSize= TStringDivision::ToULongDef(tmpV[4], 1);
+#else
+		if (!IsNocache)
+		{
+			StrSize = TStringDivision::ToULongDef(tmpV[2], 1);
+			RowSize = TStringDivision::ToULongDef(tmpV[3], 1);
+			StepSize = TStringDivision::ToULongDef(tmpV[4], 1);
+		}
+		else
+		{
+			StrSize = Parsing(SSGS, tmpV[2], 4, "List", (QWORD)Address, 0);
+			RowSize = Parsing(SSGS, tmpV[3], 4, "List", (QWORD)Address, 0);
+			StepSize = Parsing(SSGS, tmpV[4], 4, "List", (QWORD)Address, 0);
+		}
+#endif
 	    string EndWord = strD.Trim(tmpV[5]);
+#if LOCAL_MEMORY_SUPPORT
+		TSmartHandle SHandle;
+#endif
     	{//エラー文字列のセット（途中でbreakした場合、結果としてこれが返る）
+#if NOCACHED_MEMORY_LIST
+			TrimString(&tmpV[6]);
+#endif
     		string ErrorStr( tmpV[6] );
+#if LOCAL_MEMORY_SUPPORT
+			if (StepSize != 0)
+				if ((SHandle = TSSGCtrl_OpenProcess(&processCtrl, PROCESS_VM_READ, tmpV[1].c_str())) == NULL)
+					StepSize = 0;
+#endif
 	    	tmpV.clear();
     		tmpV.push_back(ErrorStr);
 	    }
+#if !FIX_DOUBLE_LIST
 	    if(StepSize==0) break;	//サイズエラー
+#else
+		if (StepSize == 0)
+		{
+			tmpV.clear();
+			break;
+		}
+#endif
 
+#if !LOCAL_MEMORY_SUPPORT
     	TSmartHandle SHandle;
 	    if(( SHandle=processCtrl.Open(PROCESS_VM_READ) )==NULL)
 	    	break;
+#endif
 
 		unsigned long i;
     	if((EndWord=="num")||(EndWord=="num_big_e")){	//数値式
+#if !FIX_DOUBLE_LIST
     		if(StrSize>4) break;	//サイズエラー
+#else
+			if (StrSize > 4)
+			{
+				tmpV.clear();
+				break;
+			}
+#endif
 
 			//1行単位に切り出し
    			tmpV.clear();
@@ -552,7 +1011,15 @@
 	    		}
 	    	}
 	    }else{	//通常文字列
+#if !FIX_DOUBLE_LIST
     		if(StrSize>StepSize) break;	//サイズエラー
+#else
+			if (StrSize > StepSize)
+			{
+				tmpV.clear();
+				break;
+			}
+#endif
 
    		 	string Val;
 	    	Val.resize(StrSize);
@@ -575,15 +1042,30 @@
 	    			Address += StepSize;
 		    	}
 			}else{	//終端文字指定
+#if !UNICODE_SUPPORT
 				string EndCode( GetSimpleByteCode(SSGS, EndWord) );
+#else
+				string EndCode((EndWord != "unicode" ? GetSimpleByteCode(SSGS, EndWord) : string()));
+#endif
 				for(i=0; i<RowSize; i++){
 					//メモリ値所得
     				if(!TProcessCtrl::OneRead(SHandle, Address, SIt, StrSize) )
 	    			    break;
 
+#if !UNICODE_SUPPORT
 			    	memcpy(tmpC, SIt, StrSize);
+#else
+					if (!EndCode.empty())
+						memcpy(tmpC, SIt, StrSize);
+					else
+						WideCharToMultiByte(CP_THREAD_ACP, 0, (LPCWSTR)SIt, StrSize / 2, tmpC, StrSize, NULL, NULL);
+#endif
 		    	    {//終端文字チェック
+#if !UNICODE_SUPPORT
     		    		unsigned long Pos = strD.Find((string&)(string)tmpC, EndCode);
+#else
+						unsigned long Pos = !EndCode.empty() ? strD.Find(string(tmpC), EndCode) : string::npos;
+#endif
 						if((size_t)Pos != string::npos) tmpC[Pos] = (char)NULL;
 		    	    }
 		    	    tmpV.push_back(tmpC);
@@ -595,7 +1077,11 @@
 		break;
     }
     //一時セット(毎回読み直す)
+#if !NOCACHED_MEMORY_LIST
 	SetSSGDataFile(&tmpV, FName, !GroupName.empty());
+#else
+	TSSGCtrl_GetSSGDataFile_FixSetSSGDataFile(this, &tmpV, FName, IsNocache);
+#endif
 	FNameIt = dataFileMap.find(strD.Lower(FName));
     if(FNameIt == dataFileMap.end())    //本来あり得ない
         return NULL;
@@ -606,6 +1092,9 @@
     CurDir = (CurrentDir==NULL)?scriptDir: *CurrentDir;
 
     FileName = strD.Half(&FName, "->", 0);
+#if FIX_GET_SSG_DATA_FILE
+    FixGetSSGDataFile(FileName);
+#endif
     if(FileName == "->"){
    	    FileName  = strD.Lower(CurDir + FName +DefaultExt);
     }else{
@@ -638,6 +1127,10 @@
 //---------------------------------------------------------------------
 void TSSGCtrl::SetSSGDataFile(vector<string> *Data, const string& FileName, bool IsSSL)
 {
+#if FIX_DOUBLE_LIST
+ if (Data->empty())
+	return;
+#endif
  map<string, vector<string> > tmpM;
  if(IsSSL){	
 	//グループ索引を作成
@@ -1115,21 +1608,49 @@
  for(; it!=End; it++){
 	it->first->Write(*This, it->second);
  }
-
- return 0;  //タイマー継続
 }
 //---------------------------------------------------------------------
 //「SSRファイルを解析する関数」
 //---------------------------------------------------------------------
+#if FIX_REPEAT
+BOOL __stdcall TSSGCtrl_ReadSSRFile_CheckSignedParam(vector<string> *tmpV)
+{
+	if (tmpV->size() >= 5)
+	{
+		char *p = (*tmpV)[4].begin();
+		while (__intrinsic_isspace(*p))
+			p++;
+		size_t length = (*tmpV)[4].end() - p;
+		if (length >= 6)
+		{
+			while (__intrinsic_isspace(*(p + length - 1)) && --length >= 6);
+			if (length == 6 && *(LPDWORD)p == BSWAP32('sign') && *(LPWORD)(p + 4) == BSWAP16('ed'))
+				return TRUE;
+		}
+	}
+	return FALSE;
+}
+//---------------------------------------------------------------------
+#endif
+#if !REPEAT_INDEX
 vector<string> TSSGCtrl::ReadSSRFile(string &Code)
+#else
+vector<string> TSSGCtrl::ReadSSRFile(string &Code, vector<DWORD> &Indices)
+#endif
 {
  unsigned long Begin, End, Step;
 
  vector<string> Dest;	//展開済みSSGスクリプトを代入するベクタ
  vector<string> *File, *StepFile=NULL;
+#if FIX_REPEAT
+ BOOL signedLoop;
+#endif
  {
     vector<string> tmpV;
 	strD.List(Code, ",", &tmpV);
+#if FIX_REPEAT
+	signedLoop = TSSGCtrl_ReadSSRFile_CheckSignedParam(&tmpV);
+#endif
 	tmpV.resize(4,"_");
 	File = GetSSGDataFile(NULL, tmpV[0], ".SSR");
 	if(File==NULL) return Dest;
@@ -1153,17 +1674,68 @@
 
  //繰り返す分の解析完了。実際の繰り返しに入る。
  if(StepFile==NULL){	//$Valの増加量は固定
+#if !FIX_REPEAT
     Dest.reserve(FormatVec.size()*((End-Begin)/Step));
+#else
+	unsigned long count;
+	if (!signedLoop)
+	{
+		count = (End - Begin) / Step;
+	}
+	else
+	{
+		count = (long)(End - Begin) / (long)Step;
+		if ((long)count < 0)
+			count = -(long)count;
+	}
+#if !REPEAT_INDEX
+	Dest.reserve(FormatVec.size() * count);
+#else
+	size_t n = FormatVec.size() * count;
+	Indices.reserve(n);
+	Dest.reserve(n);
+#endif
+#endif
 	unsigned long i;
+#if !FIX_REPEAT
 	for(i=Begin; i<End; i+=Step) LoopSSRFile(FormatVec, Dest, i);
+#else
+	for (i = Begin; !signedLoop ? i < End : (long)Step >= 0 ? (long)i < (long)End : (long)i > (long)End; i += Step)
+	{
+#if REPEAT_INDEX
+		Indices.push_back(i);
+#endif
+		LoopSSRFile(FormatVec, Dest, i);
+	}
+#endif
  }else{	//$Valの値はファイルで指定
+#if !REPEAT_INDEX
     Dest.reserve(FormatVec.size()*StepFile->size());
+#else
+	size_t n = FormatVec.size() * StepFile->size();
+	Indices.reserve(n);
+	Dest.reserve(n);
+#endif
     vector<string>::iterator
 	    VIt  = StepFile->begin(),
 	    VEnd = StepFile->end();
 	for(; VIt!=VEnd; VIt++){
 		if(VIt->empty()) continue;	//空行ならスキップ
+#if !FIX_PARSER
 		LoopSSRFile(FormatVec, Dest, TStringDivision::ToULongDef(*VIt));
+#else
+		string tmpS = *VIt;
+		ReplaceDefine(&attributeSelector, &tmpS);
+		char *endptr;
+		unsigned long LoopVal = strtoul(tmpS.c_str(), &endptr, 0);
+		if (tmpS.c_str() != endptr)
+		{
+#if REPEAT_INDEX
+			Indices.push_back(LoopVal);
+#endif
+			LoopSSRFile(FormatVec, Dest, LoopVal);
+		}
+#endif
 	}
  }
 
@@ -1172,6 +1744,37 @@
 //---------------------------------------------------------------------
 //「SSRファイルの第二解析関数」
 //---------------------------------------------------------------------
+#if FIX_REPEAT || FIX_REMOVE_SPACE
+string __stdcall TSSGCtrl_TrimString(const string &Src)
+{
+	string s(Src);
+	TrimString(&s);
+	return s;
+}
+//---------------------------------------------------------------------
+#endif
+#if FIX_REPEAT
+void __stdcall TSSGCtrl_EnumReadSSR_FormatPrefix(TStringDivision &strD, string &tmpS, list< pair<byte, string> > &LineList)
+{
+	LineList.push_back(pair<byte, string>(RT_FORMAT, TSSGCtrl_TrimString(strD.Half(&tmpS, ",").substr(1, string::npos))));
+	LineList.push_back(pair<byte, string>(RT_FORMAT, strD.Half(&tmpS, ",").substr(1, string::npos)));
+	char *begin = tmpS.begin();
+	while (__intrinsic_isspace(*begin))
+		begin++;
+	char *end = tmpS.end() - 1;
+	while (end > begin && __intrinsic_isspace(*end))
+		end--;
+	if (++end != tmpS.end() || begin != tmpS.begin())
+	{
+		size_t length = end - begin;
+		if (begin != tmpS.begin())
+			memcpy(tmpS.begin(), begin, length);
+		tmpS.resize(length);
+	}
+	LineList.push_back(pair<byte, string>(ssgCtrl::rtSTRING, tmpS));
+}
+//---------------------------------------------------------------------
+#endif
 void TSSGCtrl::EnumReadSSR(vector<string> &File,
 	vector< list< pair<byte, string> > > *FormatVec)
 {
@@ -1194,32 +1797,71 @@
 		LineList.push_back( pair<byte, string>(ssgCtrl::rtSTRING, *tmpVIt) );
 
 	for(++tmpVIt; tmpVIt!=tmpVEnd; tmpVIt++){
+#if !FIX_REMOVE_SPACE
 		tmpS = strD.Half(tmpVIt, "!]", 0, strD::etTRIM);
+#else
+		tmpS = strD.Half(tmpVIt, "!]");
+		TrimString(&tmpS);
+#endif
 		if(tmpS.size()>1){	//これが偽になるってのも変な話だが…
             switch(tmpS[0]){
             case '#':   //数値式だが、エンディアン反転をかける
+#if !FIX_REMOVE_SPACE
             	if(tmpS[1]=='L')
 				    LineList.push_back( pair<byte, string>(ssgCtrl::rtNUMBER | ssgCtrl::rtREVERSE_ENDIAN | ssgCtrl::rtDECIMAL, strD.Remove(tmpS, " ").substr(2,string::npos)) );
             	else
 				    LineList.push_back( pair<byte, string>(ssgCtrl::rtNUMBER | ssgCtrl::rtREVERSE_ENDIAN, strD.Remove(tmpS, " ").substr(1,string::npos)) );
+#else
+				if (tmpS[1] == 'L')
+					LineList.push_back(pair<byte, string>(ssgCtrl::rtNUMBER | ssgCtrl::rtREVERSE_ENDIAN | ssgCtrl::rtDECIMAL, TSSGCtrl_TrimString(tmpS).substr(2, string::npos)));
+				else
+					LineList.push_back(pair<byte, string>(ssgCtrl::rtNUMBER | ssgCtrl::rtREVERSE_ENDIAN, TSSGCtrl_TrimString(tmpS).substr(1, string::npos)));
+#endif
 				break;
             case 'L':
+#if !FIX_REMOVE_SPACE
 				LineList.push_back( pair<byte, string>(ssgCtrl::rtNUMBER | ssgCtrl::rtDECIMAL, strD.Remove(tmpS, " ").substr(1,string::npos) ) );
+#else
+				LineList.push_back(pair<byte, string>(ssgCtrl::rtNUMBER | ssgCtrl::rtDECIMAL, TSSGCtrl_TrimString(tmpS).substr(1, string::npos)));
+#endif
 				break;
             case 'R':	//ワードリピート
             	//[!R 繰り返す回数(Parsing可), 繰り返す文字列 !]
             	//[!R ($Val/2), [ ! !]　とか　[!R ($Val), +0x10:] !]
+#if !FIX_REMOVE_SPACE
 				LineList.push_back( pair<byte, string>(ssgCtrl::rtWORD_REPEAT, 
 					strD.Remove( strD.Half(&tmpS,",").substr(1,string::npos), " ") ) );
 				LineList.push_back( pair<byte, string>(ssgCtrl::rtSTRING, strD.Remove(tmpS, " ")) );
+#else
+				LineList.push_back(pair<byte, string>(ssgCtrl::rtWORD_REPEAT,
+					TSSGCtrl_TrimString(strD.Half(&tmpS, ",").substr(1, string::npos))));
+				LineList.push_back(pair<byte, string>(ssgCtrl::rtSTRING, TSSGCtrl_TrimString(tmpS)));
+#endif
             	break;
+#if FIX_REPEAT
+			case 'F':
+				TSSGCtrl_EnumReadSSR_FormatPrefix(strD, tmpS, LineList);
+				break;
+#endif
+#if !COMMON_LIST
 			case '@':	//ファイルから指定するそうです
 				//,区切りで前半部にあるファイル名部分をプッシュ
     			LineList.push_back( pair<byte, string>(ssgCtrl::rtFILE,
 	    			strD.Half(&tmpS,",").substr(1,string::npos) ) );
 	    		//そのまま下の処理へ。
+#else
+			case '@':
+				tmpS.erase(0, 1);
+			case '+':
+			case '*':
+				LineList.push_back(pair<byte, string>(ssgCtrl::rtFILE, strD.Half(&tmpS, ",")));
+#endif
             default:	//数値式
+#if !FIX_REMOVE_SPACE
 			    LineList.push_back( pair<byte, string>(ssgCtrl::rtNUMBER, strD.Remove(tmpS, " ")) );
+#else
+				LineList.push_back(pair<byte, string>(ssgCtrl::rtNUMBER, TSSGCtrl_TrimString(tmpS)));
+#endif
             }
 		}
 		if(!tmpVIt->empty())
@@ -1232,6 +1874,26 @@
 //---------------------------------------------------------------------
 //「SSRファイルの第二解析関数」
 //---------------------------------------------------------------------
+#if FIX_REPEAT
+void __stdcall TSSGCtrl_LoopSSRFile_Format(TSSGCtrl *SSGCtrl, unsigned long LoopVal, list< pair<byte, string> >::iterator &VIt, string &tmpS, TSSGSubject &SSGS, long Type)
+{
+	if (Type == RT_FORMAT)
+	{
+		char buffer[256];
+		unsigned long Val;
+
+#if !FIX_PARSER
+		Val = SSGCtrl->Parsing(&SSGS, VIt->second, LoopVal);
+#else
+		Val = SSGCtrl->Parsing(&SSGS, VIt->second, 3, "Val", (ULONGLONG)LoopVal, 0);
+#endif
+		string &Word = (++VIt)->second;
+		_snprintf(buffer, _countof(buffer), Word.c_str(), Val);
+		tmpS += buffer;
+	}
+}
+//---------------------------------------------------------------------
+#endif
 void TSSGCtrl::LoopSSRFile(vector< list< pair<byte, string> > > &FormatVec,
 	vector<string> &Dest, unsigned long LoopVal)
 {
@@ -1250,7 +1912,11 @@
 		if(Type == ssgCtrl::rtSTRING){	//不変文字列
 			tmpS += VIt->second;
 		}else if((Type & ssgCtrl::rtNUMBER)!=0){	//数値式
+#if !FIX_PARSER
 			unsigned long Val = Parsing(&SSGS, VIt->second, LoopVal);
+#else
+			unsigned long Val = Parsing(&SSGS, VIt->second, 3, "Val", (ULONGLONG)LoopVal, 0);
+#endif
 			unsigned long Mask = 0xFF000000, i;
 			for(i=4; i>1; i--){
 				if((Val&Mask)!=0) break;
@@ -1266,15 +1932,67 @@
 				tmpS += TStringDivision::ToString(Val, ("%0"+TStringDivision::ToString(i*2)+"X").c_str());
 		}else if(Type == ssgCtrl::rtFILE){	//ファイル指定
 			//SSLを使用しない場合の拡張子は、「.lst」
+#if !COMMON_LIST
 			vector<string> *File = GetSSGDataFile(&SSGS, VIt->second, ".LST");
+#else
+			vector<string> *File;
+			char prefix;
+			{
+				string FileName(VIt->second);
+				prefix = *FileName.c_str();
+				if (prefix == '+' || prefix == '*')
+					FileName.erase(0, 1);
+				File = GetSSGDataFile(&SSGS, FileName, ".LST");
+			}
+#endif
 			if(File==NULL) break;
 
+#if !FIX_PARSER
 			unsigned long Index = Parsing(&SSGS, (++VIt)->second, LoopVal);
+#else
+			unsigned long Index = Parsing(&SSGS, (++VIt)->second, 3, "Val", (ULONGLONG)LoopVal, 0);
+#endif
+#if !FIX_PARSER
 			tmpS += File->at( Index% File->size() );	//指定行の文字列を引っ張る
+#else
+			string Str = File->at(Index % File->size());
+			ReplaceDefine(&attributeSelector, &Str);
+#if COMMON_LIST
+			if (prefix == '+')
+			{
+				char *p = Str.begin();
+				while (*p && *(p++) != '=');
+				while (__intrinsic_isspace(*p))
+					p++;
+				Str.erase(0, p - Str.begin());
+			}
+			else if (prefix == '*')
+			{
+				char *p = Str.begin();
+				while (*p && *p != '=')
+					p++;
+				if (*p)
+				{
+					while (--p >= Str.begin() && __intrinsic_isspace(*p));
+					p++;
+				}
+				Str.resize(p - Str.begin());
+			}
+#endif
+			tmpS += Str;
+#endif
 		}else if(Type == ssgCtrl::rtWORD_REPEAT){	//ワードリピート
+#if !FIX_PARSER
 			unsigned long i, Count = Parsing(&SSGS, VIt->second, LoopVal);
+#else
+			unsigned long i, Count = Parsing(&SSGS, VIt->second, 3, "Val", (ULONGLONG)LoopVal, 0);
+#endif
 			string &Word = (++VIt)->second;
+#if !FIX_REPEAT
 			if(Count==0) continue;
+			if ((long)Count <= 0)
+				continue;
+			Count = 1;
 			
 			string Str;
 			Str.reserve( Word.size()*Count );
@@ -1289,7 +2007,19 @@
                 list< pair<byte, string> >::iterator tmpVIt = VIt;
 				LineList.insert(++tmpVIt, tmpFormatVec.begin()->begin(), tmpFormatVec.begin()->end());
             }
+#else
+			if ((long)Count <= 0)
+				continue;
+			for (i = 0; i < Count; i++)
+				tmpS += Word;
+#endif
+		}
+#if FIX_REPEAT
+		else
+		{
+			TSSGCtrl_LoopSSRFile_Format(this, LoopVal, VIt, tmpS, SSGS, Type);
 		}
+#endif
 	}
 	Dest.push_back(tmpS);
 	tmpS="";
@@ -1589,12 +2319,431 @@
 //「メモリ中からの値所得も範疇に入れた文字列所得関数」
 //・文字列Srcを一旦'+'で分割したあと、各々を解析し、結果を結合して返します。
 //---------------------------------------------------------------------
+#if FORMAT_NAME_STRING
+#define BRACKET_OPEN  '<'
+#define BRACKET_CLOSE '>'
+static char * __fastcall FindBracketOpen(const char *p)
+{
+	char c;
+
+	for (; c = *p; p++)
+	{
+		if (!__intrinsic_isleadbyte(c))
+		{
+			if (c != '\\')
+			{
+				if (c == BRACKET_OPEN)
+					return (char *)p;
+			}
+			else
+			{
+				if (!(c = *(++p)))
+					break;
+				if (__intrinsic_isleadbyte(c))
+					if (!*(++p))
+						break;
+			}
+		}
+		else if (!*(++p))
+		{
+			break;
+		}
+	}
+	return NULL;
+}
+//---------------------------------------------------------------------
+static char * __fastcall FindDoubleChar(const char *p, const unsigned short w)
+{
+	char c;
+
+	for (; c = *p; p++)
+	{
+		if (!__intrinsic_isleadbyte(c))
+		{
+			if (c != '\\')
+			{
+				if (c == (char)w && p[1] == (char)(w >> 8))
+					return (char *)p;
+			}
+			else
+			{
+				if (!(c = *(++p)))
+					break;
+				if (__intrinsic_isleadbyte(c))
+					if (!*(++p))
+						break;
+			}
+		}
+		else if (!*(++p))
+		{
+			break;
+		}
+	}
+	return NULL;
+}
+//---------------------------------------------------------------------
+static char * __fastcall FindDelimiter(const char *p, const char *end)
+{
+	size_t nest;
+
+	if (p >= end)
+		goto NOT_FOUND;
+	nest = 0;
+	do
+	{
+		switch (*p)
+		{
+		case '(':
+			nest++;
+			break;
+		case ')':
+			if (nest)
+				nest--;
+			break;
+		case ',':
+			if (nest)
+				break;
+			return (char *)p;
+		case '\\':
+			if (++p >= end)
+				goto NOT_FOUND;
+		default:
+			if (!__intrinsic_isleadbyte(*p) || ++p < end)
+				break;
+			goto NOT_FOUND;
+		}
+	} while (++p < end);
+NOT_FOUND:
+	return (char *)end;
+}
+//---------------------------------------------------------------------
+static char * __fastcall TrimLeft(const char *left)
+{
+	while (__intrinsic_isspace(*left))
+		left++;
+	return (char *)left;
+}
+//---------------------------------------------------------------------
+static char * __fastcall TrimRight(const char *left, const char *right)
+{
+	while (--right >= left && __intrinsic_isspace(*right));
+	return (char *)++right;
+}
+//---------------------------------------------------------------------
+static void __fastcall UnescapeString(char *p, char *end)
+{
+	if (p >= end)
+		return;
+	do
+	{
+		char c = *p;
+		if (!__intrinsic_isleadbyte(c))
+		{
+			if (c != '\\')
+				continue;
+			memcpy(p, p + 1, (end--) - p);
+			if (p >= end)
+				break;
+			c = *p;
+			if (!__intrinsic_isleadbyte(c))
+				continue;
+		}
+		p++;
+	} while (++p < end);
+}
+//---------------------------------------------------------------------
+static char * __stdcall ReplaceString(string *s, char *destBegin, char *destEnd, const char *srcBegin, const char *srcEnd)
+{
+	size_t srcLength, destLength, diff, count;
+
+	srcLength = srcEnd - srcBegin;
+	destLength = destEnd - destBegin;
+	if (diff = srcLength - destLength)
+	{
+		count = s->end() - destEnd + 1;
+		if (srcLength > destLength)
+		{
+			destBegin -= (size_t)s->begin();
+			destEnd -= (size_t)s->begin();
+			s->resize(s->size() + diff);
+			destBegin += (size_t)s->begin();
+			destEnd += (size_t)s->begin();
+			memmove(destBegin + srcLength, destEnd, count);
+		}
+		else
+		{
+			memcpy(destBegin + srcLength, destEnd, count);
+			s->resize(s->size() + diff);
+		}
+		destEnd += diff;
+	}
+	memcpy(destBegin, srcBegin, srcLength);
+	return destEnd;
+}
+//---------------------------------------------------------------------
+void __stdcall FormatNameString(TSSGCtrl *_this, TSSGSubject *SSGS, string *s)
+{
+	#define NUMBER_IDENTIFIER '#'
+	#define LIST_IDENTIFIER   '@'
+	#define NUMBER_CLOSE      (WORD)(NUMBER_IDENTIFIER | (WORD)BRACKET_CLOSE << 8)
+	#define LIST_CLOSE        (WORD)(LIST_IDENTIFIER   | (WORD)BRACKET_CLOSE << 8)
+
+	char stackBuffer[256];
+	char *bracketBegin;
+
+	bracketBegin = FindBracketOpen(s->begin());
+	while (bracketBegin)
+	{
+		char *bracketEnd;
+
+		if (bracketBegin[1] == NUMBER_IDENTIFIER)
+		{
+			char    *valueBegin, *valueEnd, *formatBegin, *formatEnd, type;
+			BOOLEAN isFEP;
+
+			bracketEnd = FindDoubleChar(bracketBegin + 2, NUMBER_CLOSE);
+			if (!bracketEnd)
+				break;
+			formatBegin = NULL;
+			type = '\0';
+			isFEP = FALSE;
+			do	/* do { ... } while (0); */
+			{
+				char *term, *fepBegin, *fepEnd;
+
+				valueBegin = TrimLeft(bracketBegin + 2);
+				valueEnd = TrimRight(valueBegin, bracketEnd);
+				bracketEnd += 2;
+				if (valueEnd == valueBegin)
+					break;
+				term = valueEnd;
+				formatBegin = FindDelimiter(valueBegin, term);
+				valueEnd = TrimRight(valueBegin, formatBegin);
+				if (formatBegin == term)
+					break;
+				formatBegin = TrimLeft(formatBegin + 1);
+				fepBegin = FindDelimiter(formatBegin, term);
+				formatEnd = TrimRight(formatBegin, fepBegin);
+				if (formatEnd != formatBegin)
+					type = *(formatEnd - 1);
+				if (fepBegin == term)
+					break;
+				fepBegin = TrimLeft(fepBegin + 1);
+				fepEnd = FindDelimiter(fepBegin, term);
+				if (fepEnd == fepBegin)
+					break;
+				fepEnd = TrimRight(fepBegin, fepEnd);
+				if (fepEnd - fepBegin != 3)
+					break;
+				if (fepBegin[0] != 'f' || fepBegin[1] != 'e' || fepBegin[2] != 'p')
+					break;
+				isFEP = TRUE;
+			} while (0);
+			switch (type)
+			{
+			case 'e': case 'E': case 'f': case 'g': case 'G': case 'a': case 'A':
+				{
+					double number;
+					UINT   length;
+					char   *buffer;
+
+					*valueEnd = '\0';
+					UnescapeString(valueBegin, valueEnd);
+					number = _this->ParsingDouble(SSGS, string(valueBegin, valueEnd), 0);
+					if (isFEP)
+						number = _this->CheckIO_FEPDouble(SSGS, number, FALSE);
+					if (formatBegin && !_isnan(number))
+						*formatEnd = '\0';
+					else
+						formatBegin = "%f";
+					length = _snprintf(stackBuffer, _countof(stackBuffer), formatBegin, number);
+					buffer = stackBuffer;
+					if (length >= _countof(stackBuffer))
+					{
+						if ((int)length >= 0)
+						{
+							UINT capacity;
+
+							if (buffer = (char *)HeapAlloc(hHeap, 0, capacity = length + 1))
+							{
+								if ((length = _snprintf(buffer, capacity, formatBegin, number)) >= capacity)
+									length = (int)length >= 0 ? capacity - 1 : 0;
+							}
+							else
+							{
+								buffer = stackBuffer;
+								length = _countof(stackBuffer) - 1;
+							}
+						}
+						else
+						{
+							length = 0;
+						}
+					}
+					bracketEnd = ReplaceString(s, bracketBegin, bracketEnd, buffer, buffer + length);
+					if (buffer != stackBuffer)
+						HeapFree(hHeap, 0, buffer);
+				}
+				break;
+			case 'n':
+				bracketEnd = ReplaceString(s, bracketBegin, bracketEnd, formatBegin, formatEnd);
+				break;
+			default:
+				{
+					DWORD number;
+					UINT  length;
+					char   *buffer;
+
+					*valueEnd = '\0';
+					UnescapeString(valueBegin, valueEnd);
+					number = _this->Parsing(SSGS, string(valueBegin, valueEnd), 0);
+					if (isFEP)
+						number = _this->CheckIO_FEP(SSGS, number, FALSE);
+					if (formatBegin && type)
+						*formatEnd = '\0';
+					else
+						formatBegin = "%d";
+					length = _snprintf(stackBuffer, _countof(stackBuffer), formatBegin, number);
+					buffer = stackBuffer;
+					if (length >= _countof(stackBuffer))
+					{
+						if ((int)length >= 0)
+						{
+							UINT capacity;
+
+							if (buffer = (char *)HeapAlloc(hHeap, 0, capacity = length + 1))
+							{
+								if ((length = _snprintf(buffer, capacity, formatBegin, number)) >= capacity)
+									length = (int)length >= 0 ? capacity - 1 : 0;
+							}
+							else
+							{
+								buffer = stackBuffer;
+								length = _countof(stackBuffer) - 1;
+							}
+						}
+						else
+						{
+							length = 0;
+						}
+					}
+					bracketEnd = ReplaceString(s, bracketBegin, bracketEnd, buffer, buffer + length);
+					if (buffer != stackBuffer)
+						HeapFree(hHeap, 0, buffer);
+				}
+				break;
+			}
+		}
+		else if (bracketBegin[1] == LIST_IDENTIFIER)
+		{
+			char *fileNameBegin, *fileNameEnd, *indexBegin, *indexEnd;
+
+			bracketEnd = FindDoubleChar(bracketBegin + 2, LIST_CLOSE);
+			if (!bracketEnd)
+				break;
+			fileNameBegin = NULL;
+			indexBegin = NULL;
+			do	/* do { ... } while (0); */
+			{
+				char *begin, *end;
+
+				begin = TrimLeft(bracketBegin + 2);
+				end = TrimRight(begin, bracketEnd);
+				bracketEnd += 2;
+				if (begin == end)
+					break;
+				fileNameBegin = begin;
+				begin = FindDelimiter(begin, end);
+				fileNameEnd = TrimRight(fileNameBegin, begin);
+				if (begin == end)
+					break;
+				begin = TrimLeft(begin + 1);
+				if (begin == end)
+					break;
+				indexBegin = begin;
+				indexEnd = end;
+			} while (0);
+			if (fileNameBegin)
+			{
+				char prefix = *fileNameBegin;
+				if (prefix == '+' || prefix == '*')
+					fileNameBegin++;
+				vector<string> *file = _this->GetSSGDataFile(SSGS, string(fileNameBegin, fileNameEnd), ".LST");
+				if (file == NULL)
+					break;
+				size_t count = file->size();
+				if (count == 0)
+					break;
+				unsigned long index;
+				if (indexBegin)
+				{
+					*indexEnd = '\0';
+					UnescapeString(indexBegin, indexEnd);
+					index = _this->Parsing(SSGS, string(indexBegin, indexEnd), 0);
+				}
+				else
+				{
+					TSSGSubjectProperty *prop = GetSubjectProperty(SSGS);
+					if (prop == NULL)
+						break;
+					index = prop->RepeatIndex;
+				}
+				string src(file->at(index % count));
+				ReplaceDefineDynamic(SSGS, &src);
+				if (prefix == '+')
+				{
+					char *p = src.begin();
+					while (*p && *(p++) != '=');
+					while (__intrinsic_isspace(*p))
+						p++;
+					src.erase(0, p - src.begin());
+				}
+				else if (prefix == '*')
+				{
+					char *p = src.begin();
+					while (*p && *p != '=')
+						p++;
+					while (--p >= src.begin() && __intrinsic_isspace(*p));
+					p++;
+					src.resize(p - src.begin());
+				}
+				bracketEnd = ReplaceString(s, bracketBegin, bracketEnd, src.begin(), src.end());
+			}
+		}
+		else
+		{
+			bracketEnd = bracketBegin + 1;
+		}
+		bracketBegin = FindBracketOpen(bracketEnd);
+	}
+
+	#undef NUMBER_CLOSE
+	#undef LIST_CLOSE
+}
+#undef BRACKET_OPEN
+#undef BRACKET_CLOSE
+//---------------------------------------------------------------------
+#endif
 string TSSGCtrl::GetNameString(TSSGSubject *SSGS, const string &NameStr)
 {
+#if !FORMAT_NAME_STRING
  vector<string> tmpV;
  if( strD.List(NameStr, "'+'", &tmpV) <= 1){
 	return AddressNaming(SSGS, NameStr);
  }
+#else
+ string s(NameStr);
+ vector<string> tmpV;
+
+#if FIX_PARSER
+ ReplaceDefineDynamic(SSGS, &s);
+#endif
+ FormatNameString(this, SSGS, &s);
+ if (strD.List(s, "'+'", &tmpV) <= 1)
+ {
+	return AddressNaming(SSGS, s);
+ }
+#endif
  
  vector<string>::iterator 
 	VIt  = tmpV.begin(),
@@ -1611,8 +2760,311 @@
  return JoinStr;
 }
 //---------------------------------------------------------------------
+#if UNICODE_SUPPORT
+void __stdcall AddressNamingFromUnicode(unsigned long DataSize, char *tmpC)
+{
+#if 0
+	HANDLE hHeap = GetProcessHeap();
+	DWORD dwBytes = (DataSize + 2) & ~1UL;
+	LPWSTR lpWideCharStr = (LPWSTR)HeapAlloc(hHeap, 0, dwBytes);
+	if (lpWideCharStr != NULL)
+	{
+		memcpy(lpWideCharStr, tmpC, dwBytes - 2);
+		*(LPWSTR)((LPBYTE)lpWideCharStr + dwBytes - 2) = L'\0';
+		WideCharToMultiByte(CP_THREAD_ACP, 0, lpWideCharStr, -1, tmpC, DataSize + 1, NULL, NULL);
+		HeapFree(hHeap, 0, lpWideCharStr);
+	}
+	else
+	{
+		*tmpC = '\0';
+	}
+#else
+	__asm
+	{
+//		push    esi
+//		push    edi
+		call    GetProcessHeap              // HANDLE hHeap = GetProcessHeap();
+		xor     ecx, ecx
+		mov     edi, dword ptr [DataSize]   // DWORD dwBytes = (DataSize + 2) & ~1UL;
+		push    ecx
+		push    ecx
+		push    eax
+		push    ecx
+		push    ecx
+		inc     edi
+		mov     esi, dword ptr [tmpC]
+		push    edi
+		push    esi
+		push    -1
+		push    ecx
+		push    ecx
+		inc     edi
+		push    CP_THREAD_ACP
+		push    edi                         // LPWSTR lpWideCharStr = (LPWSTR)HeapAlloc(hHeap, 0, dwBytes);
+		push    ecx
+		push    eax
+		call    HeapAlloc
+		test    eax, eax                    // if (lpWideCharStr != NULL)
+		jz      short L1                    // {
+		mov     ecx, edi                    //     memcpy(lpWideCharStr, tmpC, dwBytes - 2);
+		mov     edi, eax
+		shr     ecx, 1
+		mov     dword ptr [esp + 8], eax
+		dec     ecx
+		mov     dword ptr [esp + 40], eax
+		rep movsw
+		mov     word ptr [edi], cx          //     *(LPWSTR)((LPBYTE)lpWideCharStr + dwBytes - 2) = L'\0';
+		call    WideCharToMultiByte         //     WideCharToMultiByte(CP_THREAD_ACP, 0, lpWideCharStr, -1, tmpC, DataSize + 1, NULL, NULL);
+		call    HeapFree                    //     HeapFree(hHeap, 0, lpWideCharStr);
+		jmp     short L2                    // }
+		                                    // else
+		                                    // {
+	L1:
+		add     esp, 44
+		mov     byte ptr [esi], al          //     *tmpC = '\0';
+		                                    // }
+	L2:
+//		pop     edi
+//		pop     esi
+//		ret     16
+	}
+#endif
+}
+#endif
+//---------------------------------------------------------------------
+#if ADDRESS_NAMING_FEP_SUPPORT
+#include <float.h>
+void __stdcall AddressNamingFEPNumber(TSSGCtrl *SSGCtrl, TSSGSubject *SSGS, vector<string> &tmpV, unsigned long DataSize, char *tmpC)
+{
+	tmpV[3].clear();
+	if (!tmpV[5].empty())
+	{
+		switch (*tmpV[5].rbegin())
+		{
+		case 'e': case 'E': case 'f': case 'g': case 'G': case 'a': case 'A':
+			if (DataSize <= sizeof(double))
+			{
+				char   buf[256];
+				double Val;
+
+				Val =
+					DataSize == sizeof(double) ? *(double *)tmpC :
+					DataSize >= sizeof(float ) ? *(float  *)tmpC :
+					0;
+				Val = SSGCtrl->CheckIO_FEPDouble(SSGS, Val, false);
+				_snprintf(buf, _countof(buf), !_isnan(Val) ? tmpV[5].c_str() : "%f", Val);
+				tmpV[4] = buf;
+			}
+			break;
+		case 'n':
+			break;
+		default:
+			if (DataSize <= 4)
+			{
+				char          buf[256];
+				unsigned long Val;
+
+				Val =
+					DataSize == 4 ? *(LPDWORD)tmpC :
+					DataSize == 3 ? *(LPDWORD)tmpC & 0x00FFFFFF :
+					DataSize == 2 ? *(LPWORD )tmpC :
+					                *(LPBYTE )tmpC;
+				Val = SSGCtrl->CheckIO_FEP(SSGS, Val, false);
+				_snprintf(buf, _countof(buf), tmpV[5].c_str(), Val);
+				tmpV[4] = buf;
+			}
+			break;
+		}
+	}
+	*tmpC = '\0';
+}
+//---------------------------------------------------------------------
+void __stdcall AddressNamingFEPList(TSSGCtrl *SSGCtrl, TSSGSubject *SSGS, vector<string> &tmpV, unsigned long DataSize, char *tmpC)
+{
+	tmpV[3].clear();
+	if (DataSize <= 4 && !tmpV[5].empty())
+	{
+		vector<string> *vec;
+
+		vec = SSGCtrl->GetSSGDataFile(SSGS, tmpV[5], ".LST");
+		if (vec)
+		{
+			unsigned long index;
+			string        *src;
+			char          *endptr;
+			unsigned long value;
+
+			index =
+				DataSize == 4 ? *(LPDWORD)tmpC :
+				DataSize == 3 ? *(LPDWORD)tmpC & 0x00FFFFFF :
+				DataSize == 2 ? *(LPWORD )tmpC :
+				                *(LPBYTE )tmpC;
+			index = SSGCtrl->CheckIO_FEP(SSGS, index, false);
+			src = &tmpV[6];
+			if (!src->empty())
+			{
+				value = strtoul(src->c_str(), &endptr, 0);
+				if (!*endptr)
+					index -= value;
+			}
+			src = &tmpV[7];
+			if (!src->empty())
+			{
+				value = strtoul(src->c_str(), &endptr, 0);
+				if (value && !*endptr)
+					index /= value;
+			}
+			if (index < vec->size())
+			{
+				tmpV[4] = vec->at(index);
+				ReplaceDefineDynamic(SSGS, &tmpV[4]);
+			}
+		}
+	}
+	*tmpC = '\0';
+}
+//---------------------------------------------------------------------
+void __stdcall AddressNamingFEPFreeList(TSSGCtrl *SSGCtrl, TSSGSubject *SSGS, vector<string> &tmpV, unsigned long DataSize, char *tmpC)
+{
+	if (DataSize <= 4 && !tmpV[5].empty())
+	{
+		vector<string> *vec;
+
+		vec = SSGCtrl->GetSSGDataFile(SSGS, tmpV[5], ".LST");
+		if (vec)
+		{
+			unsigned long            index;
+			vector<string>::iterator it;
+
+			index =
+				DataSize == 4 ? *(LPDWORD)tmpC :
+				DataSize == 3 ? *(LPDWORD)tmpC & 0x00FFFFFF :
+				DataSize == 2 ? *(LPWORD )tmpC :
+				                *(LPBYTE )tmpC;
+			index = SSGCtrl->CheckIO_FEP(SSGS, index, false);
+			for (it = vec->begin(); it != vec->end(); it++)
+			{
+				char          *endptr;
+				unsigned long value;
+
+				tmpV[3] = *it;
+				ReplaceDefineDynamic(SSGS, &tmpV[3]);
+				string tmpS(SSGCtrl->strD.Half(&tmpV[3], "="));
+				if (tmpS.empty())
+					continue;
+				value = strtoul(tmpS.c_str(), &endptr, 0);
+				if (*endptr)
+					continue;
+				if (index != value)
+					continue;
+				tmpV[4] = tmpV[3];
+				break;
+			}
+		}
+	}
+	tmpV[3].clear();
+	*tmpC = '\0';
+}
+#endif
+//---------------------------------------------------------------------
+#if UNICODE_SUPPORT || ADDRESS_NAMING_FEP_SUPPORT
+void __stdcall AddressNamingAdditionalType(TSSGCtrl *SSGCtrl, TSSGSubject *SSGS, vector<string> &tmpV, unsigned long DataSize, char *tmpC)
+{
+	const char *p = tmpV[3].c_str();
+	switch (tmpV[3].length())
+	{
+	case 7:
+#if UNICODE_SUPPORT
+		if (*(LPDWORD)p == BSWAP32('unic'))
+		{
+			if (*(LPDWORD)(p + 4) != BSWAP32('ode\0'))
+				break;
+			tmpV[3].clear();
+			AddressNamingFromUnicode(DataSize, tmpC);
+			break;
+		}
+#endif
+#if !ADDRESS_NAMING_FEP_SUPPORT
+		break;
+#else
+		if (*(LPDWORD)p != BSWAP32('fep_'))
+			break;
+		if (*(LPDWORD)(p + 4) != BSWAP32('num\0'))
+			break;
+		AddressNamingFEPNumber(SSGCtrl, SSGS, tmpV, DataSize, tmpC);
+		break;
+	case 8:
+		if (*(LPDWORD)p != BSWAP32('fep_'))
+			break;
+		if (*(LPDWORD)(p + 4) != BSWAP32('list'))
+			break;
+		AddressNamingFEPList(SSGCtrl, SSGS, tmpV, DataSize, tmpC);
+		break;
+	case 13:
+		if (*(LPDWORD)p != BSWAP32('fep_'))
+			break;
+		if (*(LPDWORD)(p + 4) != BSWAP32('free'))
+			break;
+		if (*(LPDWORD)(p + 8) != BSWAP32('_lis'))
+			break;
+		if (p[12] != 't')
+			break;
+		AddressNamingFEPFreeList(SSGCtrl, SSGS, tmpV, DataSize, tmpC);
+		break;
+#endif
+	}
+}
+#endif
+//---------------------------------------------------------------------
 //「メモリ中からの値所得も範疇に入れた文字列所得関数」
 //---------------------------------------------------------------------
+#if ADDRESS_NAMING_FMT_SUPPORT
+BOOLEAN __stdcall TSSGCtrl_AddressNaming_OneRead(const string *NameStr, HANDLE SHandle, DWORD Address, char *tmpC, DWORD DataSize)
+{
+	do	/* do { ... } while (0); */
+	{
+		const char *p;
+
+		p = NameStr->begin();
+		while (__intrinsic_isspace(*p))
+			p++;
+		if (*p == '_')
+		{
+			p++;
+			while (__intrinsic_isspace(*p))
+				p++;
+			if (p[0] == 'v' && p[1] == 'a' && p[2] == 'l')
+			{
+				p += 3;
+				while (__intrinsic_isspace(*p))
+					p++;
+				if (*p == ',')
+					break;
+			}
+		}
+		return Address && TProcessCtrl::OneRead(SHandle, Address, tmpC, DataSize);
+	} while (0);
+	switch (DataSize)
+	{
+	case 4:
+		*(LPDWORD)tmpC = Address;
+		break;
+	case 3:
+		*(LPDWORD)tmpC = Address & 0x00FFFFFF;
+		break;
+	case 2:
+		*(LPWORD)tmpC = (WORD)Address;
+		break;
+	case 1:
+		*(LPBYTE)tmpC = (BYTE)Address;
+		break;
+	default:
+		return FALSE;
+	}
+	return TRUE;
+}
+//---------------------------------------------------------------------
+#endif
 string TSSGCtrl::AddressNaming(TSSGSubject *SSGS, const string &NameStr)
 {
  string tmpS( strD.Trim(NameStr) );
@@ -1625,7 +3077,13 @@
 	//"@ファイル->test"など
 	vector<string> *tmpV = GetSSGDataFile(SSGS, tmpS.substr(1,string::npos), ".CHN");
 	if(tmpV==NULL) return "";	//ファイルが存在しません
+#if !FIX_PARSER
 	return GetNameString(SSGS, strD.Join("", *tmpV)); }
+#else
+	tmpS = strD.Join("", *tmpV);
+	ReplaceDefineDynamic(SSGS, &tmpS);
+	return GetNameString(SSGS, tmpS); }
+#endif
  default:
     return strD.Remove(tmpS, NULL, strD::etREPLACE);
  }
@@ -1641,18 +3099,28 @@
  unsigned long DataSize;
  {//文字列データ所得
 	unsigned long Address = GetAddress(SSGS, tmpV[1]);
+#if !ADDRESS_NAMING_FMT_SUPPORT
     if(Address==0) return tmpV[4];
+#endif
 	DataSize = TStringDivision::ToULongDef(tmpV[2]);
 	if(DataSize==0) return tmpV[4];
 
 	TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
 	if(( SHandle=processCtrl.Open(PROCESS_VM_READ) )==NULL)
+#else
+	if ((SHandle = TSSGCtrl_OpenProcess(&processCtrl, PROCESS_VM_READ, tmpV[1].c_str())) == NULL)
+#endif
 		return tmpV[4];	//プロセスのオープンエラー
 
     tmpC = new char[DataSize+1];
     tmpC[DataSize]=(char)NULL;
 
+#if !ADDRESS_NAMING_FMT_SUPPORT
 	if(!TProcessCtrl::OneRead(SHandle, Address, tmpC, DataSize)){
+#else
+	if (!TSSGCtrl_AddressNaming_OneRead(&NameStr, SHandle, Address, tmpC, DataSize)) {
+#endif
         delete[] tmpC;
  		return tmpV[4]; //エラーならtmpV[4]を返す
 	}
@@ -1673,7 +3141,15 @@
 		//"_mem,0x430000,4,list,Error,ファイル名, 初項, 公差"
 		Index = (Index-TStringDivision::ToULongDef(tmpV[6]))/TStringDivision::ToULongDef(tmpV[7],1);
 		if(Index < List->size())
+#if !FIX_PARSER
 			return List->at(Index);
+#else
+		{
+			tmpS = List->at(Index);
+			ReplaceDefineDynamic(SSGS, &tmpS);
+			return tmpS;
+		}
+#endif
 	}else if(tmpV[3]=="free_list"){	//フリーリスト式
 		//"_mem,0x430000,8,予約(00),Error, lstファイル名"
 		string tmpS;
@@ -1683,6 +3159,9 @@
 		for(; VIt!=VEnd; VIt++){
 			//リストファイルは「Index=文字列」形式で羅列
 			tmpS = *VIt;
+#if FIX_PARSER
+			ByteArrayReplaceDefine(SSGS, &tmpS);
+#endif
 			if(Index!= TStringDivision::ToULongDef( strD.Half(&tmpS,"=") ))
 				continue;
 			return tmpS;
@@ -1699,6 +3178,7 @@
 
 	string Ret;
 	switch(*tmpV[5].rbegin()){//[tmpV[5].size()-1]){
+#if !FIX_FORMAT
 	case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':{
 		if(DataSize>4){
 			Ret=tmpV[4];	break;
@@ -1708,19 +3188,52 @@
 		Ret = TStringDivision::ToString(Val, tmpV[5].c_str());
 		break;}
 	case 'e': case 'E': case 'f': case 'g': case 'G':{
+#else
+	case 'e': case 'E': case 'f': case 'g': case 'G': case 'a': case 'A': {
+#endif
 		if(DataSize>8){
 			Ret=tmpV[4];	break;
 		}
+#if !FIX_ADDRESS_NAMING_FROM_FLOAT
 		double Val = 0;
 		memcpy(&Val, tmpC, DataSize);	//数値と見なす
 		Ret = TStringDivision::ToString(Val, tmpV[5].c_str());
+#else
+		double Val =
+			DataSize >= sizeof(double) ? *(double *)tmpC :
+			DataSize >= sizeof(float ) ? *(float  *)tmpC :
+			0;
+		Ret = TStringDivision::ToStringDouble(Val, tmpV[5].c_str());
+#endif
 		break;}
+#if !FIX_FORMAT
 	default:
 		Ret=tmpV[4]; //エラーならtmpV[4]を返す
+#else
+	case 'n':
+		Ret = tmpV[4];
+		break;
+	default:
+		if (DataSize > 4)
+		{
+			Ret = tmpV[4];
+		}
+		else
+		{
+			unsigned long Val = 0;
+			memcpy(&Val, tmpC, DataSize);
+			Ret = TStringDivision::ToString(Val, tmpV[5].c_str());
+		}
+		break;
+#endif
 	}
 	delete[] tmpC;
 	return Ret;
  }
+#if UNICODE_SUPPORT || ADDRESS_NAMING_FEP_SUPPORT
+ else
+	AddressNamingAdditionalType(this, SSGS, tmpV, DataSize, tmpC);
+#endif
 
  string Data;
  Data = tmpC;
@@ -1764,12 +3277,309 @@
 //---------------------------------------------------------------------
 //「バイト列文字列からvector<TProcessAccessElementBase*>を生成する関数」
 //---------------------------------------------------------------------
+#if FIX_LOOP_BYTE_ARRAY
+void __stdcall TSSGCtrl_StrToProcessAccessElementVec_FixLoopByteArray(
+	TSSGCtrl                          *SSGCtrl,
+	TSSGSubject                       *SSGS,
+	string                            &Code,
+	TProcessAccessElementBase         *NowAE,
+	unsigned long                     PosEnd,
+	unsigned long                     PosSep,
+	unsigned long                     FillSize,
+	list<TProcessAccessElementBase *> &CodeList)
+{
+	const char *find = NULL;
+	const char *p = Code.c_str() + PosSep + 2;
+	const char *end = Code.c_str() + PosEnd;
+	if (p + 4 < end)
+	{
+		end -= 4;
+		do
+		{
+			if (*(LPDWORD)p != /*BSWAP32('$Rel')*/'leR$' || !__intrinsic_isascii(*(p + 4)) || __intrinsic_iscsym(*(p + 4)))
+			{
+				if (!__intrinsic_isleadbyte(*p))
+					p++;
+				else
+					p += 2;
+			}
+			else
+			{
+				find = p;
+				break;
+			}
+		} while (p < end);
+	}
+	if (find == NULL)
+	{
+		vector<TProcessAccessElementBase *> LoopVec(SSGCtrl->StrToProcessAccessElementVec(SSGS, Code.substr(PosSep + 2, PosEnd - (PosSep + 2))));
+		((TProcessAccessElementLoop*)NowAE)->MakeLoopSet(FillSize, LoopVec, true);
+	}
+	else if (FillSize != 0)
+	{
+		string LoopCode = Code.substr(PosSep + 2, PosEnd - (PosSep + 2));
+		DWORD Rel = 0;
+		for (; ; )
+		{
+			vector<TProcessAccessElementBase *> LoopVec(SSGCtrl->StrToProcessAccessElementVec(SSGS, LoopCode, Rel));
+			for (vector<TProcessAccessElementBase *>::iterator it = LoopVec.begin(); it != LoopVec.end(); it++)
+			{
+				DWORD NextRel = Rel + (*it)->GetSize(true);
+				if (NextRel < FillSize)
+				{
+					Rel = NextRel;
+					CodeList.push_back(*it);
+				}
+				else
+				{
+					if (NextRel != FillSize)
+						(*it)->SetSize(FillSize - Rel, true);
+					CodeList.push_back(*it);
+					return;
+				}
+			}
+		}
+	}
+}
+//---------------------------------------------------------------------
+#endif
+#if FIX_REMOVE_SPACE
+void __stdcall TSSGCtrl_ByteArrayRemoveSpace(string &Code)
+{
+	char *p1, *end;
+
+	TrimString(&Code);
+	p1 = Code.begin();
+	end = Code.end();
+	while (p1 < end)
+	{
+		char ch;
+
+		ch = *p1;
+		if (!__intrinsic_isleadbyte(ch))
+		{
+			if (__intrinsic_isspace(ch))
+			{
+				char *p2;
+
+				p2 = p1 + 1;
+				while (__intrinsic_isspace(*p2))
+					p2++;
+				memcpy(p1, p2, end - p2);
+				*(end -= p2 - p1) = '\0';
+				continue;
+			}
+			if (ch == '$')
+			{
+				p1 += 2;
+				for (; ; )
+				{
+					if (p1 >= end)
+						goto OUTER_BREAK;
+					ch = *p1;
+					if (!__intrinsic_isleadbyte(ch))
+					{
+						p1++;
+						if (ch != '$' || *p1 != '$')
+							continue;
+						else
+							break;
+					}
+					else
+						p1 += 2;
+				}
+			}
+			p1++;
+		}
+		else
+			p1 += 2;
+	}
+OUTER_BREAK:
+	if (end != Code.end())
+		Code.resize(end - Code.begin());
+}
+//---------------------------------------------------------------------
+#endif
+#if FIX_BYTE_ARRAY_FIND
+LPCSTR __stdcall TSSGCtrl_ByteArraySkipReplacementType(LPCSTR SrcIt, LPCSTR SrcEnd, unsigned long Option)
+{
+	SrcIt++;
+	for (; ; )
+	{
+		char ch;
+
+		ch = *(SrcIt++);
+		if (SrcIt >= SrcEnd)
+			break;
+		if (!__intrinsic_isleadbyte(ch))
+		{
+			if (ch != '\\')
+			{
+				if (ch != '$' || *SrcIt != '$')
+					continue;
+				SrcIt++;
+				break;
+			}
+			if (!(Option & strD::dtESCAPE))
+				continue;
+			ch = *SrcIt;
+			if (__intrinsic_isleadbyte(ch))
+				SrcIt++;
+		}
+		SrcIt++;
+	}
+	return SrcIt;
+}
+//---------------------------------------------------------------------
+#define TokenLength 2
+size_t __stdcall TSSGCtrl_ByteArrayFind(const string &Src, const char Token[TokenLength], unsigned long FromIndex, unsigned long ToIndex, unsigned long Option)
+{
+	size_t SrcLength;
+	LPCSTR SrcIt, SrcEnd;
+
+	if (FromIndex == ToIndex)
+		return SIZE_MAX;
+
+	SrcLength = Src.length();
+
+	if (SrcLength < TokenLength)
+		return SIZE_MAX;
+
+	if (SrcLength < ToIndex || SrcLength < ToIndex + TokenLength)
+		ToIndex = SrcLength - TokenLength + 1;
+
+	SrcIt = Src.c_str() + FromIndex;
+	SrcEnd = Src.c_str() + ToIndex;
+
+	while (SrcIt < SrcEnd)
+	{
+		char ch;
+
+		ch = *(SrcIt++);
+		if (!__intrinsic_isleadbyte(ch))
+		{
+			size_t NCount;
+
+			switch (ch)
+			{
+			case '*':
+				ch = *SrcIt;
+				if (Token[0] == '*' && Token[1] == ch)
+					goto TOKEN_FOUND;
+				switch (ch)
+				{
+				case '<':
+				case '[':
+				case '{':
+					goto NEST_START_TAG1;
+				default:
+					continue;
+				}
+			case '<':
+				if (*SrcIt != '_')
+					continue;
+			NEST_START_TAG1:
+				NCount = 1;
+				SrcIt++;
+				for (; ; )
+				{
+					ch = *(SrcIt++);
+					if (SrcIt >= SrcEnd)
+						goto FAILED;
+					if (!__intrinsic_isleadbyte(ch))
+					{
+						switch (ch)
+						{
+						case '*':
+							switch (*SrcIt)
+							{
+							case '<':
+							case '[':
+							case '{':
+								goto NEST_START_TAG2;
+							case '>':
+							case ']':
+							case '}':
+								goto NEST_END_TAG;
+							default:
+								continue;
+							}
+						case '<':
+							if (*SrcIt != '_')
+								continue;
+						NEST_START_TAG2:
+							NCount++;
+							SrcIt++;
+							continue;
+						case '_':
+							if (*SrcIt != '>')
+								continue;
+						NEST_END_TAG:
+							if (--NCount == 0)
+								goto NESTED_BREAK;
+							SrcIt++;
+							continue;
+						case '$':
+							SrcIt = TSSGCtrl_ByteArraySkipReplacementType(SrcIt, SrcEnd, Option);
+							if (SrcIt < SrcEnd)
+								continue;
+							else
+								goto FAILED;
+						case '\\':
+							if (!(Option & strD::dtESCAPE))
+								continue;
+							ch = *SrcIt;
+							if (__intrinsic_isleadbyte(ch))
+								SrcIt++;
+							break;
+						default:
+							continue;
+						}
+					}
+					SrcIt++;
+				}
+			NESTED_BREAK:
+				continue;
+			case '$':
+				SrcIt = TSSGCtrl_ByteArraySkipReplacementType(SrcIt, SrcEnd, Option);
+				continue;
+			case '\\':
+				if (!(Option & strD::dtESCAPE))
+					continue;
+				ch = *SrcIt;
+				if (__intrinsic_isleadbyte(ch))
+					SrcIt++;
+				break;
+			default:
+				if (Token[0] == ch && Token[1] == *SrcIt)
+				{
+			TOKEN_FOUND:
+					return SrcIt - Src.c_str() - 1;
+				}
+				continue;
+			}
+		}
+		SrcIt++;
+	}
+FAILED:
+	return SIZE_MAX;
+}
+#undef TokenLength
+//---------------------------------------------------------------------
+#endif
+#if !FIX_LOOP_BYTE_ARRAY
 vector<TProcessAccessElementBase*> TSSGCtrl::StrToProcessAccessElementVec(
 	TSSGSubject *SSGS, string Code)
+#else
+vector<TProcessAccessElementBase *> TSSGCtrl::StrToProcessAccessElementVec(TSSGSubject *SSGS, string Code, unsigned long Rel)
+#endif
 {
 
  Code = strD.Trim(Code);
  if(Code.empty()) return vector<TProcessAccessElementBase*>();
+#if FIX_PARSER
+ ByteArrayReplaceDefine(SSGS, &Code);
+#endif
  if(Code[0] == 's'){	//文字列形式
 	TProcessAccessElementData *NowAE= new TProcessAccessElementData();
 	vector<byte> *DataV = NowAE->GetData();
@@ -1779,10 +3589,23 @@
 		SIt  = Code.begin()+1,
 		SEnd = Code.end();
 	for(; SIt!=SEnd; SIt++){
+#if !OPTIMIZE_STRINGDIVISION
 		if( ((byte)*SIt != '\\')||(strD.IsHeadByte(Code,SIt)!=0) ){
 			DataV->push_back( (byte)*SIt );
 			continue;
 		}
+#else
+		if (*SIt != '\\')
+		{
+			if (__intrinsic_isleadbyte(*SIt))
+			{
+				DataV->push_back((byte)*SIt);
+				SIt++;
+			}
+			DataV->push_back((byte)*SIt);
+			continue;
+		}
+#endif
 		if((++SIt)==SEnd) break;
 
 		if((byte)*SIt=='\\'){
@@ -1808,7 +3631,11 @@
  list<TProcessAccessElementBase*> CodeList;
 
 
+#if !FIX_REMOVE_SPACE
  Code = strD.Remove(Code," ");
+#else
+ TSSGCtrl_ByteArrayRemoveSpace(Code);
+#endif
 
  string tmpS;
  //仮要素なので、連続データにならないTProcessAccessElementBase派生クラスならなんでも良い。
@@ -1847,13 +3674,25 @@
 			strD.SetDividOption(&NewNestStartTag, &NewNestEndTag);
 
 			//*{ C2DD00 :: FFDDFF :: DD00DD *}
+#if !FIX_BYTE_ARRAY_FIND
 			unsigned long PosEndIf = strD.Find(Code, NewNestEndTag, i+2, string::npos, strD::dtNEST);
+#else
+			unsigned long PosEndIf = TSSGCtrl_ByteArrayFind(Code, NewNestEndTag.c_str(), i + 2, string::npos, 0);
+#endif
 			if((size_t)PosEndIf==string::npos) break;	//対応するEND_IFがない！
 
+#if !FIX_BYTE_ARRAY_FIND
 			unsigned long PosTrue  = strD.Find(Code, "::", i+2, PosEndIf, strD::dtNEST+strD::dtESCAPE);
+#else
+			unsigned long PosTrue = TSSGCtrl_ByteArrayFind(Code, "::", i + 2, PosEndIf, strD::dtESCAPE);
+#endif
 			if((size_t)PosTrue==string::npos) break;	//対応する真判定の処理がない！
 			
+#if !FIX_BYTE_ARRAY_FIND
 			unsigned long PosFalse = strD.Find(Code, "::", PosTrue+2, PosEndIf , strD::dtNEST+strD::dtESCAPE);
+#else
+			unsigned long PosFalse = TSSGCtrl_ByteArrayFind(Code, "::", PosTrue + 2, PosEndIf, strD::dtESCAPE);
+#endif
 			strD.SetDividOption(&OldNestStartTag, &OldNestEndTag);  //元に戻す
 
 			((TProcessAccessElementIf*)NowAE)->SetConditionVec(	//条件式の解析へ
@@ -1919,21 +3758,42 @@
 			strD.SetDividOption(&NewNestStartTag, &NewNestEndTag);
 
 			//*[ 0x40 :: FFDDFF *]
+#if !FIX_BYTE_ARRAY_FIND
 			unsigned long PosEnd = strD.Find(Code, NewNestEndTag, i+2, string::npos, strD::dtNEST);
+#else
+			unsigned long PosEnd = TSSGCtrl_ByteArrayFind(Code, NewNestEndTag.c_str(), i + 2, string::npos, 0);
+#endif
 			if((size_t)PosEnd==string::npos) break;	//対応するENDがない！
 
+#if !FIX_BYTE_ARRAY_FIND
 			unsigned long PosSep  = strD.Find(Code, "::", i+2, PosEnd, strD::dtNEST+strD::dtESCAPE);
+#else
+			unsigned long PosSep = TSSGCtrl_ByteArrayFind(Code, "::", i + 2, PosEnd, strD::dtESCAPE);
+#endif
 			if((size_t)PosSep==string::npos) break;	//対応する処理バイト列がない！
 			
 			strD.SetDividOption(&OldNestStartTag, &OldNestEndTag);  //元に戻す
 			
 			//フィルサイズはアドレス式で記述
+#if !FIX_LOOP_BYTE_ARRAY
 			unsigned long FillSize = GetAddress(SSGS, Code.substr(i+2, PosSep-(i+2)) );
 			vector<TProcessAccessElementBase *> LoopVec(	//ループ分のバイト列を解析
 				StrToProcessAccessElementVec(SSGS, Code.substr(PosSep+2, PosEnd-(PosSep+2))) );
 			
 			//ループデータの設定
 			((TProcessAccessElementLoop*)NowAE)->MakeLoopSet( FillSize, LoopVec, true );
+#else
+			unsigned long FillSize = GetAddress(SSGS, Code.substr(i + 2, PosSep - (i + 2)), 0);
+			TSSGCtrl_StrToProcessAccessElementVec_FixLoopByteArray(
+				this,
+				SSGS,
+				Code,
+				NowAE,
+				PosEnd,
+				PosSep,
+				FillSize,
+				CodeList);
+#endif
 			i = PosEnd;	//命令終端まで読み飛ばす
 			break;}
 		}
@@ -1943,7 +3803,11 @@
 		if((size_t)PosEnd==string::npos) break;
 
 		//アドレスコーディング部分を抜き出して解析
+#if !FIX_LOOP_BYTE_ARRAY
 		unsigned long Val = Parsing(SSGS, (string)Code.substr(i+2, PosEnd-(i+2)), 0);
+#else
+		unsigned long Val = Parsing(SSGS, (string)Code.substr(i + 2, PosEnd - (i + 2)), 3, "Rel", (ULONGLONG)Rel, 0);
+#endif
 
 		vector<byte> Data;
 		switch(Code[i+1]){	//何バイトの値に変換するかで振り分ける
@@ -1983,10 +3847,18 @@
 			strD.SetDividOption(&NewNestStartTag, &NewNestEndTag);
 
 			//<_ A020 :: FFCC _>	マスクデータ::実データ
+#if !FIX_BYTE_ARRAY_FIND
 			unsigned long PosEnd = strD.Find(Code, NewNestEndTag, i+2, string::npos, strD::dtNEST);
+#else
+			unsigned long PosEnd = TSSGCtrl_ByteArrayFind(Code, NewNestEndTag.c_str(), i + 2, string::npos, 0);
+#endif
 			if((size_t)PosEnd==string::npos) break;	//対応するENDがない！
 
+#if !FIX_BYTE_ARRAY_FIND
 			unsigned long PosSep  = strD.Find(Code, "::", i+2, PosEnd, strD::dtNEST+strD::dtESCAPE);
+#else
+			unsigned long PosSep = TSSGCtrl_ByteArrayFind(Code, "::", i + 2, PosEnd, strD::dtESCAPE);
+#endif
 			if((size_t)PosSep==string::npos) break;	//対応する処理バイト列がない！
 			
 			strD.SetDividOption(&OldNestStartTag, &OldNestEndTag);  //元に戻す
@@ -2087,9 +3959,72 @@
     string OnCode, string &OffCode, bool IsOn,
     unsigned long StartAddress, unsigned long OffsetAddress)
 {
+#if !FIX_TOGGLE_BYTE_ARRAY
  string AddressStr( strD.Half(&OnCode, "-", 0, strD::dtESCAPE) );
  if(AddressStr=="-")	//繰り返しなし
 	return StrToProcessAccessElementVec(SSGS, (IsOn)? OnCode: OffCode );
+#else
+	LPCSTR lpFind, lpSrc, lpPtr;
+	char   ch;
+
+	lpFind = NULL;
+	lpSrc = OnCode.c_str();
+	for (lpPtr = lpSrc; (ch = *lpPtr) != '\0'; lpPtr++)
+	{
+		if (!__intrinsic_isleadbyte(ch))
+		{
+			if (ch == '-')
+			{
+				lpFind = lpPtr;
+				break;
+			}
+			if (ch == '$')
+			{
+				ch = *(lpPtr + 1);
+				if ((BYTE)ch < (BYTE)'1' || (BYTE)ch > (BYTE)'4')
+					continue;
+				lpPtr++;
+				while ((ch = *(++lpPtr)) != '\0')
+				{
+					if (!__intrinsic_isleadbyte(ch))
+					{
+						if (ch == '$')
+						{
+							if (*(lpPtr + 1) == '$')
+								break;
+							else
+								continue;
+						}
+						if (ch != '\\')
+							continue;
+						if ((ch = *(++lpPtr)) == '\0')
+							break;
+						if (!__intrinsic_isleadbyte(ch))
+							continue;
+					}
+					if ((ch = *(++lpPtr)) == '\0')
+						break;
+				}
+				if (ch != '\0')
+					continue;
+				else
+					break;
+			}
+			if (ch != '\\')
+				continue;
+			if ((ch = *(++lpPtr)) == '\0')
+				break;
+			if (!__intrinsic_isleadbyte(ch))
+				continue;
+		}
+		if (*(++lpPtr) == '\0')
+			break;
+	}
+	if (lpFind == NULL)
+		return StrToProcessAccessElementVec(SSGS, IsOn ? OnCode : OffCode);
+	string AddressStr(lpSrc, lpFind - lpSrc);
+	OnCode = lpFind + 1;
+#endif
 
  vector<TProcessAccessElementBase*> LoopVec( StrToProcessAccessElementVec(SSGS, (IsOn)? OnCode: OffCode) );
 
@@ -2130,7 +4065,13 @@
  unsigned long i=0, End=List->size();
  for(; i<End; i++){
 	if(List->at(i).empty()) continue;
+#if !FIX_PARSER
 	strD.List(List->at(i), ",", &tmpV);
+#else
+	string Src(List->at(i));
+	ReplaceDefineDynamic(SSGS, &Src);
+	strD.List(Src, ",", &tmpV);
+#endif
 	tmpV.resize(3);
 
 	Address = GetAddress(SSGS, tmpV[1]);
@@ -2143,7 +4084,11 @@
 		CompareVec = MakeDataCode(SSGS, tmpV[2], string(""), true, Address,0);
 	}else{
 		//結果が偽(0)なら、次の条件式へ
+#if !FIX_PARSER
 		if( Parsing(SSGS, tmpV[0], Val) == 0 ) continue;
+#else
+		if (Parsing(SSGS, tmpV[0], 3, "Val", (ULONGLONG)Val, 0) == 0) continue;
+#endif
 
 		CompareVec = MakeDataCode(SSGS, tmpV[2], string(""), true, Address,0);
 		i=End;	//処理後、抜けます
@@ -2152,7 +4097,12 @@
 	if(CompareVec.GetData()->empty()) continue;
 
 	//ファンネルライト発動
+#if !LOCAL_MEMORY_SUPPORT
 	if(Write(SSGS, SHandle, &Address, *CompareVec.GetData())!=0) return false;
+#else
+	if (Write(SSGS, TSSGCtrl_IsRemoteProcess(tmpV[1].c_str()) ? (HANDLE)SHandle : ::GetCurrentProcess(), &Address, *CompareVec.GetData()) != 0)
+		return false;
+#endif
  }
 
  return true;
@@ -2167,7 +4117,11 @@
  TIO_FEPAttribute *tmpAE = (TIO_FEPAttribute *)GetAttribute(SSGS, ssgCtrl::atIO_FEP);
  if(tmpAE==NULL) return Val;
 
+#if !FIX_PARSER
  return Parsing(SSGS, (string)((IsInput)?tmpAE->GetInputCode(): tmpAE->GetOutputCode()), Val);
+#else
+ return Parsing(SSGS, (string)((IsInput) ? tmpAE->GetInputCode() : tmpAE->GetOutputCode()), 3, "Val", (ULONGLONG)Val, 0);
+#endif
 }
 //---------------------------------------------------------------------
 double TSSGCtrl::CheckIO_FEPDouble(TSSGSubject *SSGS, double Val, bool IsInput)
@@ -2181,8 +4135,14 @@
 //「[enabled]属性をチェックし、有効な項目かどうかを判定する関数」
 //	・[enabled]属性は多段適用式なので、保持属性すべてを洗い出してチェックします。
 //---------------------------------------------------------------------
+#if !SUBJECT_STATUS
 bool TSSGCtrl::IsEnabled(TSSGSubject *SSGS)
 {
+#else
+bool TSSGCtrl::IsEnabled(TSSGSubject *SSGS, BOOLEAN evaluateAtRead/* = FALSE*/)
+{
+ SSGS->evaluateAtRead = evaluateAtRead;
+#endif
  vector<TSSGAttributeElement *> *AttrV = SSGS->GetAttribute();
  if(AttrV==NULL) return true;
 
@@ -2220,6 +4180,9 @@
 //---------------------------------------------------------------------
 //「文字列Srcを、一旦逆ポーランド記法にしたあと解析する関数」
 //---------------------------------------------------------------------
+#if FIX_PARSER
+#include "Parsing.c"
+#else
 unsigned long TSSGCtrl::Parsing(TSSGSubject *SSGS, const string &Src, unsigned long Val)
 {
  vector<string> tmpV, SentenceVec;
@@ -2461,14 +4424,24 @@
 
  return Operand.top();
 }
+#endif
 //---------------------------------------------------------------------
 //「プロセスのオープン関数」
 //---------------------------------------------------------------------
 HANDLE TSSGCtrl::Open(TSSGSubject *SSGS, DWORD Mode)
 {
+#if !LOCAL_MEMORY_SUPPORT
  if(ssgActionListner==NULL) return processCtrl.Open(Mode);
+#else
+ if (ssgActionListner == NULL)
+	return TSSGCtrl_OpenProcess(&processCtrl, Mode, SSGS->GetAddressStr().c_str());
+#endif
 
+#if !LOCAL_MEMORY_SUPPORT
  HANDLE Handle = processCtrl.Open(Mode);
+#else
+ HANDLE Handle = TSSGCtrl_OpenProcess(&processCtrl, Mode, SSGS->GetAddressStr().c_str());
+#endif
  if(Handle==NULL){
 	ssgActionListner->OnProcessOpenError(SSGS);
 	return NULL;
@@ -2509,6 +4482,16 @@
 	ssgActionListner->OnSubjectWriteSuccess(SSGS, OldAddress);
     return 0;
  }
+#if ERRORSKIP_SUPPORT
+#define AT_ERRORSKIP 0x2000
+ if (GetAttribute(SSGS, AT_ERRORSKIP))
+ {
+	if (MainForm->GetUserMode() == 3)
+		return 0;
+	Ret = 0;
+ }
+#undef AT_ERRORSKIP
+#endif
  ssgActionListner->OnSubjectWriteError(SSGS, OldAddress);
  return Ret;
 }
@@ -2545,6 +4528,33 @@
  ssgActionListner->OnSubjectReadError(SSGS, Address);
  return false;
 }
+#if IO_FEP_SUPPORT
+//---------------------------------------------------------------------
+BOOLEAN __stdcall TSSGCtrl_OneRead_with_CheckIO_FEP(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size)
+{
+	if (!_this->OneRead(SSGS, ProcessHandle, Address, Data, Size))
+		return FALSE;
+	if (SSGS->isFEP)
+		*(LPDWORD)Data = _this->CheckIO_FEP(SSGS, *(LPDWORD)Data, false);
+	return TRUE;
+}
+//---------------------------------------------------------------------
+BOOLEAN __stdcall TSSGCtrl_OneRead_with_CheckLocalMemory_CheckIO_FEP(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size, const string &AddressStr)
+{
+	if (TSSGCtrl_OneRead_with_CheckLocalMemory(_this, SSGS, ProcessHandle, Address, Data, Size, AddressStr))
+	{
+		if (SSGS->isFEP)
+		{
+			*(LPDWORD)Data = _this->CheckIO_FEP(SSGS, *(LPDWORD)Data, false);
+		}
+		return TRUE;
+	}
+	else
+	{
+		return FALSE;
+	}
+}
+#endif
 //---------------------------------------------------------------------
 //「プロセスメモリの簡易ライト関数」
 //---------------------------------------------------------------------
@@ -2560,6 +4570,22 @@
  ssgActionListner->OnSubjectWriteError(SSGS, Address);
  return false;
 }
+#if IO_FEP_SUPPORT
+//---------------------------------------------------------------------
+BOOLEAN __stdcall TSSGCtrl_OneWrite_with_CheckIO_FEP(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size)
+{
+	if (SSGS->isFEP)
+		*(LPDWORD)Data = _this->CheckIO_FEP(SSGS, *(LPDWORD)Data, true);
+	return _this->OneWrite(SSGS, ProcessHandle, Address, Data, Size);
+}
+//---------------------------------------------------------------------
+BOOLEAN __stdcall TSSGCtrl_OneWrite_with_CheckLocalMemory_CheckIO_FEP(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size, const string &AddressStr)
+{
+	if (SSGS->isFEP)
+		*(LPDWORD)Data = _this->CheckIO_FEP(SSGS, *(LPDWORD)Data, true);
+	return TSSGCtrl_OneWrite_with_CheckLocalMemory(_this, SSGS, ProcessHandle, Address, Data, Size, AddressStr);
+}
+#endif
 //---------------------------------------------------------------------
 //「プロセスメモリの簡易比較関数」
 //---------------------------------------------------------------------
