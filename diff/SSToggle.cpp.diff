--- spal60sr\src\TSSGCtrl\SSToggle.original.cpp	Sun Apr 20 17:58:56 2003
+++ spal60sr\src\TSSGCtrl\SSToggle.cpp	Sun Apr 20 17:58:56 2003
@@ -1,5 +1,7 @@
 #include "SSToggle.h"
 
+#define LOCAL_MEMORY_SUPPORT 1
+
 //---------------------------------------------------------------------
 //「初期設定関数」
 //
@@ -14,14 +16,23 @@
  
  vector<string> tmpV;
  
+#if !SUBJECT_STRING_TABLE
  SSGC.strD.List(code+SSGC.GetEndWith(this), ",", &tmpV, strD::etTRIM+strD::dtESCAPE);
+#else
+ SSGC.strD.List((string&)code + SSGC.GetEndWith(this), ",", &tmpV, strD::etTRIM | strD::dtESCAPE);
+#endif
  tmpV.resize(3);	//規定数に
 
  addressStr = tmpV[0];
  onCode  = tmpV[1];
  offCode = tmpV[2];
+#if !SUBJECT_STATUS
  TSmartVector<TProcessAccessElementBase> AEV  //項目サイズ計測用
 	( SSGC.MakeDataCode(this, onCode, offCode, true, SSGC.GetAddress(this, addressStr), 0) );
+#else
+ TSmartVector<TProcessAccessElementBase> AEV  //項目サイズ計測用
+	(SSGC.MakeDataCode(this, onCode, offCode, true, (unsigned long)(address = (const BYTE *)SSGC.GetAddress(this, addressStr)), 0));
+#endif
  size = TProcessAccessElementBase::GetTotalSize(*AEV.GetData(), true);
 
  //名称も切り分ける
@@ -48,14 +59,25 @@
  Setting(SSGC);
  
  TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
  if(( SHandle=SSGC.Open(this, PROCESS_VM_READ) )==NULL)
+#else
+ if ((SHandle = SSGC.Open(this, PROCESS_VM_READ, addressStr.c_str())) == NULL)
+#endif
 	return ssgCtrl::reOPEN_ERROR;	//プロセスのオープンエラー
 
+#if !SUBJECT_STATUS
  if(!SSGC.IsEnabled(this)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
+#else
+ if(!SSGC.IsEnabled(this, TRUE)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
+#endif
 
 
  //属性を適用
  unsigned long Address = SSGC.GetAddress(this, addressStr);
+#if SUBJECT_STATUS
+ address = (const BYTE *)Address;
+#endif
 
  if(onCode.empty()) return ssgCtrl::reOPTION_ERROR;	//ON値がないです(^^;
 
@@ -82,7 +104,11 @@
  Setting(SSGC);
  
  TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
  if(( SHandle=SSGC.Open(this, PROCESS_VM_READ|PROCESS_VM_WRITE|PROCESS_VM_OPERATION) )==NULL)
+#else
+ if ((SHandle = SSGC.Open(this, PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, addressStr.c_str())) == NULL)
+#endif
 	return ssgCtrl::reOPEN_ERROR;	//プロセスのオープンエラー
 
  if(!SSGC.IsEnabled(this)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
@@ -90,6 +116,9 @@
 
  //属性を適用
  unsigned long Address = SSGC.GetAddress(this, addressStr);
+#if SUBJECT_STATUS
+ address = (const BYTE *)Address;
+#endif
 
  //*+や??などを考慮しながら、vector<TProcessAccessElementBase *>化
  TSmartVector<TProcessAccessElementBase> CompareVec
